"use strict";(self.webpackChunkselectdb_portal=self.webpackChunkselectdb_portal||[]).push([[11477],{30010:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/principle-of-Doris-SQL-parsing","metadata":{"permalink":"/blog/principle-of-Doris-SQL-parsing","source":"@site/blog/principle-of-Doris-SQL-parsing.md","title":"Doris analysis: Doris SQL principle analysis","description":"\x3c!--","date":"2022-08-25T00:00:00.000Z","formattedDate":"August 25, 2022","tags":[{"label":"Tech Sharing","permalink":"/blog/tags/tech-sharing"}],"truncated":false,"authors":[{"name":"Apache Doris"}],"frontMatter":{"title":"Doris analysis: Doris SQL principle analysis","summary":"This article mainly introduces the principle of Doris SQL parsing.Since there are many types of SQL, this article focuses on the analysis of query SQL. Doris\'s SQL analysis will be explained deeply in the algorithm principle and code implementation.","date":"2022-08-25","author":"Apache Doris","tags":["Tech Sharing"]},"nextItem":{"title":"How Flink\'s real-time writes to Apache Doris ensure both high throughput and low latency","permalink":"/blog/Flink-realtime-write"}},"content":"\x3c!-- \\nLicensed to the Apache Software Foundation (ASF) under one\\nor more contributor license agreements.  See the NOTICE file\\ndistributed with this work for additional information\\nregarding copyright ownership.  The ASF licenses this file\\nto you under the Apache License, Version 2.0 (the\\n\\"License\\"); you may not use this file except in compliance\\nwith the License.  You may obtain a copy of the License at\\n\\n  http://www.apache.org/licenses/LICENSE-2.0\\n\\nUnless required by applicable law or agreed to in writing,\\nsoftware distributed under the License is distributed on an\\n\\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\nKIND, either express or implied.  See the License for the\\nspecific language governing permissions and limitations\\nunder the License.\\n--\x3e\\n\\n**Lead\uff1a**\\nThis article mainly introduces the principle of Doris SQL parsing.\\n\\nIt focuses on generating a single-machine logical plan, developing a distributed logical plan, and generating a distributed physical plan. Analyze, SinglePlan, DistributedPlan, and Schedule four parts correspond to the code implementation.\\n\\nFirst, AST will be processed preliminary by Analyze and then optimized by SinglePlan to generate a single-machine query plan. Third, DistributedPlan will split the single-machine query plan into distributed query plans. In the end, the query plan will be sent to machines and executed orderly, which decide by Schedule.\\n\\nSince there are many types of SQL, this article focuses on the analysis of query SQL. Doris\'s SQL analysis will be explained deeply in the algorithm principle and code implementation.\\n\\n# 1. Introduction to Doris\\nDoris is an interactive SQL database based on MPP architecture, mainly used to solve near real-time reports and multi-dimensional analysis. The Doris architecture is straightforward, with only two types of processes.\\n\\n- Frontend\uff08FE\uff09: It is mainly responsible for user request access, query parsing and planning, storage and management of metadata, and node management-related work.\\n\\n- Backend\uff08BE\uff09: It is mainly responsible for data storage and query plan execution.\\n\\nIn Doris\' storage engine, data will be horizontally divided into several data shards (Tablet, also called data bucket). Each tablet contains several rows of data. Multiple Tablets belong to different partitions logically. A Tablet only belongs to one Partition. And a Partition contains several Tablets. Tablet is the smallest physical storage unit for operations such as data movement, copying, etc.\\n\\n# 2. SQL parsing In Apache Doris\\nSQL parsing in this article refers to **the process of generating a complete physical execution plan after a series of parsing of an SQL statement**.\\n\\nThis process includes the following four steps: lexical analysis, syntax analysis, generating a logical plan, and generating a physical plan.\\n\\n![](/images/blogs/principle-of-Doris-SQL-parsing/Figure_1_en.png)\\n\\n## 2.1 Lexical analysis\\nThe lexical analysis will identify the SQL in the form of a string into tokens, in preparation for the grammatical analysis.\\n```undefined\\nselect ......  from ...... where ....... group by ..... order by ......\\n\\nSQL Tokens could be divided into the following categories:\\n\uffee Keywords (select, from, where)\\n\uffee operator (+, -, >=)\\n\uffee Open/close flag ((, CASE)\\n\uffee placeholder (?)\\n\uffee Comments\\n\uffee space\\n......\\n```\\n## 2.2 Syntax analysis\\nThe syntax analysis will convert the token generated by the lexical analysis into an abstract syntax tree based on the syntax rules, as shown in Figure 2.\\n\\n![](/images/blogs/principle-of-Doris-SQL-parsing/Figure_2_en.png)\\n\\n## 2.3 Logical plan\\nThe logical plan converts the abstract syntax tree into an algebraic relation, which is an operator tree, and each node represents a calculation method for data. The entire tree represents the calculation method and flows direction of data, as shown in Figure 3.\\n\\n ![](/images/blogs/principle-of-Doris-SQL-parsing/Figure_3_en.png)\\n\\n## 2.4 Physical plan\\nThe physical plan is the plan that determines which computing operations are performed on which machines. It will be generated based on the logical plan, the distribution of machines, and the distribution of data.\\n\\nThe SQL parsing of the Doris system also adopts these steps, but it is refined and optimized according to the characteristics of the Doris system structure and the storage method of data to maximize the computing power of the machine.\\n\\n# 3. Design goals\\nThe design goals of the Doris SQL parsing architecture are:\\n\\n1. Maximize Computational Parallelism\\n\\n2. Minimize network transfer of data\\n\\n3. Minimize the amount of data that needs to be scanned\\n\\n# 4. Architecture\\nDoris SQL parsing includes five steps: lexical analysis, syntax analysis, generation of a stand-alone logical plan, generation of a distributed logical plan, and generation of a physical execution plan.\\n\\nIn terms of code implementation, it corresponds to the following five steps: Parse, Analyze, SinglePlan, DistributedPlan, and Schedule, which as shown in Figure 4.\\n\\n![](/images/blogs/principle-of-Doris-SQL-parsing/Figure_4_en.png)\\n\\nThe Parse phase will not be discussed in this article. Analyze will do some pre-processing of the AST. A stand-alone query plan will be optimized by SinglePlan based on the AST. DistributedPlan will split the stand-alone query plan into distributed query plans. Schedule phase will determine which machines the query plan will be sent to for execution.\\n\\n**Since there are many types of SQL, this article focuses on the analysis of query SQL.**\\n\\nFigure 5 shows a simple query SQL parsing implementation in Doris.\\n\\n![](/images/blogs/principle-of-Doris-SQL-parsing/Figure_5_en.png)\\n\\n# 5. Parse Phase\\nIn the Parse stage, JFlex technology is used for lexical analysis, java cup parser technology is used for syntax analysis, and an AST\uff08Abstract Syntax Tree\uff09will finally generate. These are existing and mature technologies and will not be introduced in detail here.\\n\\nAST has a tree-like structure, which represents a piece of SQL. Therefore, different types of queries -- select, insert, show, set, alter table, create table, etc. will generate additional data structures after Parse (SelectStmt, InsertStmt, ShowStmt, SetStmt, AlterStmt, AlterTableStmt, CreateTableStmt, etc.). However, they all inherit from Statements and will perform some specific processing according to their own grammar rules. For example: for select type SQL, the SelectStmt structure will be generated after Parse.\\n\\nSelectStmt structure contains SelectList, FromClause, WhereClause, GroupByClause, SortInfo and other structures. These structures contain more basic data structures. For Example, WhereClause contains BetweenPredicate, BinaryPredicate, CompoundPredicate, InPredicate, and so on.\\n\\nAll structures in AST are composed of basic structure expressions--Expr by using various combinations, as shown in Figure 6.\\n\\n![](/images/blogs/principle-of-Doris-SQL-parsing/Figure_6_en.png)\\n# 6. Analyze Phase\\nAnalyze will perform pre-processing and semantic analysis on the abstract syntax tree AST generated in the Parse phase, preparing for the generation of stand-alone logic plans.\\n\\nThe abstract class StatementBase represents the abstract syntax tree. This abstract class contains a most crucial member function--analyze(), which is used to perform what\'s needed to do in Analyze phase.\\n\\nDifferent types of queries (select, insert, show, set, alter table, create table, etc.) will generate different data structures through the Parse stage(SelectStmt, InsertStmt, ShowStmt, SetStmt, AlterStmt, AlterTableStmt, CreateTableStmt, etc.), these data structures inherit From StatementBase, and perform a specific Analysis on a specific type sof SQL by implementing the analyze() function.\\n\\nFor example, a query of select type will be converted into analyze() of the sub-statements SelectList, FromClause, GroupByClause, HavingClause, WhereClause, SortInfo, etc. of select SQL. Then these sub-statements further analyze() their sub-structures, and various scenarios of various types of SQL are analyzed by layer-by-layer iteration. For example, WhereClause will further explore the BetweenPredicate, BinaryPredicate, CompoundPredicate, InPredicate, etc., which it contains.\\n\\n**For query type SQL, Analyze will performs several important steps:**\\n\\n- **Metadata identification and parsing**\uff1a Identify and parse metadata such as Cluster, Database, Table, Column, etc. involved in SQL, and determine which columns, tables, databases, and clusters need to be calculated.\\n\\n- **SQL correctness check**\uff1asuch as the window function cannot DISTINCT, whether the projection column is ambiguous, the where statement cannot contain grouping operations, etc.\\n\\n- **Rewrite SQL simply**\uff1afor example, expand select * to select all columns, convert count distinct to bitmap or hll function, etc.\\n\\n- **Function correctness check**\uff1aCheck whether the functions contained in SQL are consistent with the system-defined procedures, including parameter types, number of parameters, etc.\\n\\n- **Aliasing for Table and Column.**\\n\\n- **Type checking and conversion**\uff1a For example, when the types on both sides of a binary expression are inconsistent, one of the types needs to be converted (with BIGINT and DECIMAL, the BIGINT type needs to be cast to DECIMAL).\\n\\nAfter analyzing the AST, a rewrite operation will be performed again to simplify or convert it into a unified processing method. A present rewrite algorithm is a rule-based approach. It will rewrite the AST with each rule from bottom to top, based on the tree structure of the AST. If the AST changes after rewriting, analysis and rewrite will start again until there is no change in the AST.\\n\\nFor example: simplification of constant expressions: 1 + 1 + 1 is rewritten as 3, 1 > 2 is rewritten as Flase, etc. Convert some statements into a unified processing method, such as rewriting where in, where exists as semi join, where not in, where not exists as anti join.\\n\\n# 7. Generate stand-alone logical Plan phase\\nAt this stage, algebraic relations will be generated according to the AST abstract syntax tree, also known as the operator number. Each node on the tree is an operator, representing an operation.\\n\\nAs shown in Figure 7, ScanNode represents scan and read operations on a table. HashJoinNode represents the join operation. A hash table of a small table will be constructed in memory, and the large table will be traversed to find the exact value of the join key. Project means the projection operation, which represents the column that needs to be output at the end. Figure 7 shows that only citycode column will output.\\n\\n![](/images/blogs/principle-of-Doris-SQL-parsing/Figure_7_en.png)\\n\\nWithout optimization, the generated relational algebra is very expensive to send to storage and execute.\\n\\nFor query:\\n```sql\\nselect a.siteid, a.pv from table1 a join table2 b on a.siteid = b.siteid where a.citycode=122216 and b.username=\\"test\\" order by a.pv limit 10\\n```\\nAs shown in Figure 8, for unoptimized relational algebra, all columns need to be read out for a series of calculations. In the end, siteid and pv column are selected and output. A large amount of useless column data wastes computing resources.\\n\\nWhen Doris generates algebraic relations, a lot of optimizations are made: the projection columns and query conditions will be put into the scan operation as much as possible.\\n\\n![](/images/blogs/principle-of-Doris-SQL-parsing/Figure_8_en.png)\\n\\n**Specifically, this phase mainly does the following tasks:**\\n\\n- **Slot materialization**\uff1aDetermine the column that needs to be scanned and calculated for the expression. Such as aggregate function expressions and Group By words of aggregate nodes need to be materialized.\\n\\n- **Projection pushdown**\uff1aBE only scans the columns that must be read when Scanning.\\n\\n- **Predicate pushdown**\uff1aPush down the filter conditions to the Scan node as much as possible under the premise of semantically correct.\\n\\n- **Partition, bucket cutting**\uff1aAccording to the information in the filter conditions, determine which partitions and buckets of tablets need to be scanned.\\n\\n- **Join Reorder**\uff1aFor Inner Join, Doris will adjust the order of the table according to the number of rows--put the large table in the front.\\n\\n- **Sort + Limit optimized to TopN**\uff1aFor the order by the limit statement, it will be converted into TopN operation nodes, which is convenient for unified processing.\\n\\n- **MaterializedView selection**: The best-materialized view will be selected according to the columns required by the query, the columns for filtering, sorting and Join, the number of rows, the number of columns, and other factors.\\n\\nFigure 9 shows an example of optimization. The optimization of Doris is carried out in generating relational algebra. Generating one will optimize one.\xb7 Projection pushdown: BE only scans the columns that must be read when Scanning.\\n\\n![](/images/blogs/principle-of-Doris-SQL-parsing/Figure_9_en.png)\\n\\n# 8 Generate Distributed Plan Phase\\n\\nAfter the single-machine PlanNode tree is generated, it needs to be split into a distributed PlanFragment tree (PlanFragment is used to represent an independent execution unit) according to the distributed environment. A table\'s data is distributed across multiple hosts could allow some computations to be parallelized.\\n\\nThe primary purpose of this step is to maximize parallelism and data localization. The primary strategy is to split the nodes that can be executed in parallel and create a separate PlanFragment. ExchangeNodes will replace the split nodes to receive data. Finally, a DataSinkNode will be added to the split node to transmit the calculated data to the ExchangeNode for further processing.\\n\\nThis step adopts a recursive method, traverses the entire PlanNode tree from bottom to top, and then creates a PlanFragment for each leaf node on the tree. If the parent node is encountered, splitting the child nodes that can be executed in parallel will be considered.\\n\\nFor query operations, the join operation is the most common.\\n\\n**Doris currently supports four join algorithms:** broadcast join, hash partition join, colocate join, and bucket shuffle join.\\n\\n**broadcast join**\uff1aSend the small table to each machine where the large table is located and perform a hash join operation. When the amount of data scanned from a table is small, the cost of broadcast join will be calculated, and the method with the smallest cost will be selected by calculating and comparing the cost of hash partitions.\\n\\n**hash partition join**\uff1aWhen the data scanned from the two tables are both large, hash partition join is generally used. It traverses all the data in the table, calculates the hash value of the key, then modulizes the number of clusters, and whichever machine is selected, the data will be sent to this machine for hash join operation.\\n\\n**colocate join**\uff1aIf the data distribution of the two tables is specified to be consistent when they are created, the colocate join algorithm will be used when the join key of the two tables is the same as the bucket key. Since the data distribution of the two tables is the same, the hash join operation is equivalent to a local process. It does not involve data transmission, which significantly improves query performance.\\n\\n**bucket shuffle join**\uff1aWhen the join key is a bucketing key, and only one partition is involved, the bucket shuffle join algorithm is preferred. Since bucketing itself represents a way of dividing data, it only needs to take the hash modulo of the number of buckets from the right table to the left table, so that only one copy of the data in the right table needs to be transmitted over the network, which greatly reduces the network of data transmission, as shown in Figure 10.\\n\\n![](/images/blogs/principle-of-Doris-SQL-parsing/Figure_10_en.png)\\n\\nFigure 11 shows the core process of creating a distributed logical plan with a single-machine logical plan with HashJoinNode.\\n\\n- For PlanNodes, PlanFragments are created bottom-up.\\n\\n- If it is a ScanNode, PlanFragment will be created directly, and the RootPlanNode of the PlanFragment is this ScanNode.\\n\\n- If it is a HashJoinNode, the broadcastCost will be calculated at first, which could provide a reference for selecting boracast join or hash partition join.\\n\\n- Join algorithm will be chosen according to different conditions.\\n\\n- If colocate joins are used, since joins are all local, no splitting is required. Set the left child node of HashJoinNode as the RootPlanNode of leftFragment, and the right child node as the RootPlanNode of rightFragment, share a PlanFragment with leftFragment, and delete rightFragment.\\n\\n- If bucket shuffle join is used, data from the right table needs to be sent to the left table. So first create an ExchangeNode, set the left child node of HashJoinNode as the RootPlanNode of leftFragment, the right child node as this ExchangeNode, share a PlanFragment with leftFragment, and specify the destination of rightFragment data to be sent to this ExchangeNode.\\n\\n- If broadcast join is used, the data from the right table needs to be sent to the left table. So first create an ExchangeNode, set the left child node of HashJoinNode as the RootPlanNode of leftFragment, the right child node as this ExchangeNode, share a PlanFragment with leftFragment, and specify the destination of rightFragment data to be sent to this ExchangeNode.\\n\\n- If hash partition join is used, the data in the left table and the right table must be split, and both left and right nodes need to be split out to create left ExchangeNode and right ExchangeNode respectively. HashJoinNode specifies the left and right nodes as left ExchangeNode and right ExchangeNode. Create a PlanFragment separately and specify RootPlanNode as this HashJoinNode. Finally, specify the data sending destination of leftFragment and rightFragment as left ExchangeNode and right ExchangeNode.\\n\\n![](/images/blogs/principle-of-Doris-SQL-parsing/Figure_11_en.png)\\n\\nFigure 12 is an example after the join operation of two tables is converted into a PlanFragment tree, there are 3 PlanFragments generated. The final output data passes through the ResultSinkNode node.\\n\\n![](/images/blogs/principle-of-Doris-SQL-parsing/Figure_12_en.png)\\n\\n# 9. Schedule phase\\n\\nThis step is to create a distributed physical plan based on the distributed logical plan. will solve the following questions:\\n\\n- Which BE executes which PlanFragment\\n\\n- Which replica to chooes for each Tablet to query\\n\\n- How to perform multi-instance concurrency\\n\\n**Figure 13 shows the core process for creating a distributed physical plan:**\\n\\n**a. Prepare phase**\uff1aCreate a FragmentExecParams structure for each PlanFragment to represent all the parameters required for PlanFragment execution; if a PlanFragment contains DataSinkNode, the destination PlanFragment for data transmission will be found, and specify the input of FragmentExecParams of the destination PlanFragment as FragmentExecParams of this PlanFragment.\\n\\n**b. computeScanRangeAssignment phase**\uff1aDifferent processing is performed for different types of joins.\\n\\n- computeScanRangeAssignmentByColocate: For colocate join processing, since the data distribution in the two table buckets of the join is the same, they are based on the bucket join operation, so here is to determine which host is selected for each bucket. When allocating buckets to hosts, try to ensure that the buckets allocated to each host are even.\\n\\n- computeScanRangeAssignmentByBucket: Processing for bucket shuffle join, which is only based on bucket operations, so here is to determine which host is selected for each bucket. When allocating buckets to hosts, it is also necessary to try to ensure that the buckets allocated to each host are even.\\n\\n- computeScanRangeAssignmentByScheduler: Process for other types of joins. Determines which replica of the tablet each scanNode reads. A scanNode will read multiple tablets, and each tablet has various copies. To distribute the scan operation on various machines as much as possible, improve concurrent performance, and reduce IO pressure, Doris uses the Round-Robin algorithm to distribute tablet scans to multiple machines as much as possible. For example, 100 tablets need to be scanned, each tablet has three copies, and ten machines could be used. When allocating, each machine is guaranteed to scan ten tablets.\\n\\n**c.computeFragmentExecParams phase**\uff1aThis stage determines which BE the PlanFragment is issued to for execution and how to handle instance concurrency. After the scan address of each tablet is determined, FragmentExecParams will generate multiple instances with the address as the dimension. If various addresses are contained in FragmentExecParams, various instances of FInstanceExecParam will be generated. If the concurrency is set, the execution instance of an address will be further split into multiple FInstanceExecParams. There will be some special processing for bucket shuffle join and colocate join, but the basic logic is the same. After FInstanceExecParam is created, a unique ID will be assigned to facilitate tracking information. If FragmentExecParams contains ExchangeNode, the number of senders will be counted to know how many senders\' data needs to be accepted. Finally, FragmentExecParams determines the destinations and fills in the destination address.\\n\\n**d. Create result receiver stage**\uff1aThe resulting receiver is where the final data needs to be output after the query is completed.\\n\\n**e. to thrift stage**\uff1aCreate RPC requests based on FInstanceExecParam of all PlanFragments, then send them to the BE side for execution. A complete SQL parsing process is completed.\\n\\n![](/images/blogs/principle-of-Doris-SQL-parsing/Figure_13_en.png)\\n\\nFigure 14 is a simple example. The PlanFrament in the figure contains a ScanNode. The ScanNode scans three tablets. Each tablet has two copies, and the cluster assumes that there are two hosts.\\n\\nThe computeScanRangeAssignment stage determines that replicas 1, 3, 5, 8, 10, and 12 need to be scanned, where replicas 1, 3, and 5 are located on host1, and replicas 8, 10, and 12 are located on host2.\\n\\nIf the global concurrency is set to 1, 2 instances of FInstanceExecParam are created and sent to host1 and host2 for execution. If the global concurrency is set to 3, 3 instances of FInstanceExecParam are created on this host1, and three instances of FInstanceExecParam are created on host2. Each instance scans one replica, equivalent to initiating 6 RPC requests.\\n\\n![](/images/blogs/principle-of-Doris-SQL-parsing/Figure_14_en.png)\\n\\n# 10 Summary\\nThis article first briefly introduces Doris and then introduces the general process of SQL parsing: lexical analysis, syntax analysis, generating logical plans, and generating physical plans. Then, it presents the overall architecture of DorisSQL parsing. In the end, the five processes:  Parse, Analyze, SinglePlan, DistributedPlan, and Schedule are explained in detail, and an in-depth explanation is given of the algorithm principle and code implementation.\\n\\nDoris complies with the standard methods of SQL parsing. Still, according to the underlying storage architecture and distributed characteristics, many optimizations have been made in SQL parsing to achieve maximum parallelism and minimize network transmission, reducing a lot of burden on the SQL execution level."},{"id":"/Flink-realtime-write","metadata":{"permalink":"/blog/Flink-realtime-write","source":"@site/blog/Flink-realtime-write.md","title":"How Flink\'s real-time writes to Apache Doris ensure both high throughput and low latency","description":"\x3c!--","date":"2022-07-29T00:00:00.000Z","formattedDate":"July 29, 2022","tags":[{"label":"Tech Sharing","permalink":"/blog/tags/tech-sharing"}],"truncated":false,"authors":[{"name":"Apache Doris"}],"frontMatter":{"title":"How Flink\'s real-time writes to Apache Doris ensure both high throughput and low latency","summary":"With the increasing demand for real-time analysis, the timeliness of data is becoming more and more important to the refined operation of enterprises. With the massive data, real-time data warehouse plays an irreplaceable role in effectively digging out valuable information, quickly obtaining data feedback, helping companies make faster decisions and better product iterations.","date":"2022-07-29","author":"Apache Doris","tags":["Tech Sharing"]},"prevItem":{"title":"Doris analysis: Doris SQL principle analysis","permalink":"/blog/principle-of-Doris-SQL-parsing"},"nextItem":{"title":"Apache Doris announced the official release of version 1.1.1","permalink":"/blog/release-1.1.1"}},"content":"\x3c!-- \\nLicensed to the Apache Software Foundation (ASF) under one\\nor more contributor license agreements.  See the NOTICE file\\ndistributed with this work for additional information\\nregarding copyright ownership.  The ASF licenses this file\\nto you under the Apache License, Version 2.0 (the\\n\\"License\\"); you may not use this file except in compliance\\nwith the License.  You may obtain a copy of the License at\\n\\n  http://www.apache.org/licenses/LICENSE-2.0\\n\\nUnless required by applicable law or agreed to in writing,\\nsoftware distributed under the License is distributed on an\\n\\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\nKIND, either express or implied.  See the License for the\\nspecific language governing permissions and limitations\\nunder the License.\\n--\x3e\\n\\n\\n\\nWith the increasing demand for real-time analysis, the timeliness of data is becoming more and more important to the refined operation of enterprises. With the massive data, real-time data warehouse plays an irreplaceable role in effectively digging out valuable information, quickly obtaining data feedback, helping companies make faster decisions and better product iterations.\\n\\nIn this situation, Apache Doris stands out as a real-time MPP analytic database, which is high performance and easy to use, and supports various data import methods. Combined with Apache Flink, users can quickly import unstructured data from Kafka and CDC(Change Data Capture) from upstream database like MySQL. Apache Doris also provides sub-second analytic query capabilities, which can effectively satisfy the needs of several real-time scenarios: multi-dimensional analysis, dashboard and data serving etc.\\n# Challange\\n\\nUsually, there are many challenges to ensure high end-to-end concurrency and low latency for real-time data warehouses , such as:\\n\\n- How to ensure end-to-end data sync in second-level ?\\n\\n- How to quickly ensure data visibility ?\\n\\n- How to solve the problem of small files writing under high concurrency situation?\\n\\n- How to ensure end-to-end Exactly-Once?\\n\\nWithin the challenges above , we conducted an in-depth research on the business scenarios of users using Flink and Doris to build real-time data warehouses . After grasping the pain points of users, we made targeted optimizations in Doris version 1.1 and greatly improved the user experience  and improved the stability. The resource consumption of Doris has also been greatly optimized.\\n\\n# Optimization\\n\\n### Streamming Write\\n\\nThe initial practice of Flink Doris Connector is to cache the data into the memory batch after receiving data.The method of data writing is saving batches, and using parameters such as `batch.size` and `batch.interval` to control the timing of Stream Load writing at the same time.\\n\\nIt usually runs stably when the parameters are reasonable. Whatever the parameters are unreasonable, it would cause frequent Stream Load and compaction untimely, resulting in excessive version errors ( -235 ). On the other hand, when there is too much data, in order to reduce the writing frequency of Stream Load , the setting of `batch.size` too large may also cause OOM.\\n\\n**To solve this problem, we introduce streaming write:**\\n\\n![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/otliigutb8p9l1y6qyp6.png)\\n- After the Flink task starts, the Stream Load Http request will be asynchronously initiated.\\n\\n- When the data is received, it will be continuously transmitted to Doris through the Chunked transfer encoding of Http.\\n\\n- Http request will end at Checkpoint and complete the Stream Load writing . The next Stream Load request will be asynchronously initiated at the same time.\\n\\n- The data will continue to be received and the follow-up process is the same as above.\\n\\nThe pressure on the memory of the batch is avoided since the Chunked mechanism is used to transmit data. And the timing of writing is bound to the Checkpoint, which makes the timing of Stream Load controllable, and provides a basis for the following Exactly-Once semantics.\\n\\n### Exactly-Once\\n\\nExactly-Once means that data will not be reprocessed or lost, even machine or application failure. Flink supports the End-to-End\'s Exactly-Once scenario a long time ago, mainly through the two-phase commit protocol to realize the Exactly-Once semantics of the Sink operator.\\n\\nOn the basis of Flink\'s two-stage submission, with the help of Doris 1.0\'s Stream Load two-stage submission,Flink Doris Connector implements Exactly Once semantics. The specific principles are as follows:\\n\\n- When the Flink task is started, it will initiate a Stream Load PreCommit request. At this time, a transaction will be opened first, and data will be continuously sent to Doris through the Chunked mechanism of Http.\\n\\n![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ole5tqi91jibzdg9vqep.png)\\n\\n- Http request will be completed when the data writing ends at Checkpoint , and set the transaction status to preCommitted. The data has been written to BE and is invisible to the user at this time.\\n\\n![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/jiieu1eff6smunkr85s5.png)\\n\\n- A Commit request will be initiated after the Checkpoint, and the transaction status will be set to Committed. The data will become visible to the user after request.\\n\\n![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/eaona8eslljmkpaa9324.png)\\n\\n- After the Flink application ends unexpectedly and restarts from Checkpoint, if the last transaction was in the preCommitted state, a rollback request will be initiated and the transaction state will be set to Aborted.\\n\\nBased on the above , Flink Doris Connector can be used to realize real-time data storage without loss or weight.\\n\\n### Second- Level Data Synchronization\\n\\nEnd-to-end second-level data sync and real-time visibility of data in high concurrent write scenarios require Doris to have the following capabilities:\\n\\n- **Transaction Processing Capability**\\n\\nFlink real-time writing interacts with Doris in the form of Stream Load 2pc, which requires Doris to have the corresponding transaction processing capabilities to ensure the basic ACID characteristics, and support Flink\'s second-level data sync in high concurrency scenarios.\\n\\n- **Rapid Aggregation Capability of Data Versions**\\n\\nOne import in Doris will generate one data version. In a high concurrent write scenario, an inevitable impact is that there are too many data versions, and the amount of data imported in a single time will not be too large. The continuous high-concurrency small file writing scenario extremely tests the real-time ability and Doris\' data merging performance, which is not friendly to Doris, and in turn affects the performance of the query. Doris has greatly enhanced the data compaction capability in version 1.1, which can quickly complete the aggregation of new data, avoiding -235 errors and query efficiency problems which are caused by too many versions of sharded data.\\n\\nFirst of all, in Doris 1.1 version, QuickCompaction was introduced, which can actively triggered Compaction when the data version increased. At the same time, by improving the ability to scan fragment meta information, fragments that need to be compacted can be quickly discovered and trigger Compaction. Through active triggering and passive scanning, the real-time problem of data merging is completely solved.\\n\\nFor high-frequency small file Cumulative Compaction, the scheduling and isolation of Compaction tasks is implemented to prevent the heavyweight Base Compaction from affecting the merging of new data.\\n\\nFinally, the strategy of merging small files is optimized by adopting gradient merge method. Each time the files participating in the merging belong to the same data magnitude,which can prevent versions with large differences in size from merging, and gradually merges hierarchically, reducing the number of times a single file is involved in merging, which can greatly save the CPU consumption of the system.\\n\\n![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ez5qdcpgwjw60g9aacqd.png)\\n\\nDoris version 1.1 has made targeted optimizations for scenarios such as high concurrent import, second-level data sync, and real-time data visibility, which greatly increases the ease of use and stability of the Flink system and Doris system, saves the overall resources of the cluster.\\n\\n# Effect\\n\\n### General Flink High Concurrency Scenarios\\n\\nIn the general scenario of the survey, Flink is used to synchronize unstructured data in upstream Kafka. The data is written to Doris in real time by the Flink Doris Connector after ETL.\\n\\nThe customer scenario is extremely strict here. The upstream maintains a high frequency of 10w per second, and the data needs to be able to complete the upstream and downstream sync within 5s to achieve second-level data visibility. Flink is configured with 20 concurrency, and the Checkpoint interval is 5s. The performance of Doris version 1.1 is quite excellent.\\n\\nSpecifically reflected in the following aspects:\\n\\n- **Compaction Real-Time**\\n\\nData can be merged quickly, the number of tablet data versions is kept below 50, and the compaction score is stable. Compared with the previous -235 problem in high concurrent import scenario, the compaction efficiency is improved more than 10 times.\\n\\n![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/d6enyv1zj68o7myjypnl.png)\\n\\n-  **CPU Resource Consumption**\\n\\nDoris version 1.1 has optimized the strategy for compaction of small files. In high-concurrency import scenarios, CPU resource consumption is reduced by 25%.\\n\\n- **QPS Query Delay is Stable**\\n\\nBy reducing the CPU usage and the number of data versions, the overall order of data has been improved, and the delay of SQL queries will be reduced.\\n\\n### Second-Level Data Synchronization Scenario (Extreme High Pressure)\\n\\nIn single bet and single tablet with 30 concurrent limit stream load pressure test on the client side, data in real-time <1s, the comparison before and after compaction score optimization as below:\\n\\n![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/r01hn8hv6arzbdclknis.png)\\n# Recommendations\\n\\n### Real-Time Data Visualization Scenario\\n\\nFor strict latency requirements scenarios, such as second-level data synchronization, usually mean that a single import file is small, and it is recommended to reduce `cumulative_size_based_promotion_min_size_mbytes `. The default unit is 64 MB, and you can set it to 8 MB manually, which can greatly improve the compaction real-time performance. \\n\\n### High Concurrency Scenario\\n\\nFor high concurrent writing scenarios, you can reduce the frequency of Stream Load by increasing the checkpoint interval. For example, setting checkpoint to 5-10s can not only increase the throughput of Flink tasks, but also reduce the generation of small files and avoid causing compaction more pressure.\\n\\nIn addition, for scenarios that do not require high real-time data, such as minute-level data sync, the checkpoint interval can be increased, such as 5-10 minutes. And the Flink Doris connector can still ensure the integrity of data through the two-stage submission and checkpoint mechanism.\\n\\n# Future planning\\n\\n-  **Real-time Schema Change**\\n\\nWhen accessing data in real time through Flink CDC, the upstream business table will perform the schema change operation, it has to modify the schema manually in Doris and Flink tasks. In the end, the data of the new schema can be synchronized after restart the task . \\n\\nThis way requires human intervention, which will bring a great operation burden to users. In subsequent versions, real-time schema changes will support CDC scenarios, and the upstream schema changes will be synchronized to the downstream in real-time, which will comprehensively improve the efficiency of schema changes.\\n\\n-  **Doris Multi-table Writting**\\n\\nAt present, the Doris Sink operator only supports synchronizing a single table, so for the entire database, it still has to divide the flow manually at the Flink level and write to multiple Doris Sinks, which will increase the difficulty of developers. In subsequent versions, we will support a single Doris Sink to synchronize multiple tables, which greatly simplifies the user\'s operation.\\n\\n-  **Adaptive Compaction Parameter Tuning**\\n\\nAt present, the compaction strategy has many parameters, which can play a good role in most general scenarios, but these strategies still can\'t play an efficient role in some special scenarios. We will continue to optimize in subsequent versions, carry out adaptive compaction tuning for different scenarios, and keep improving data merging efficiency and real-time performance in various scenarios.\\n\\n-  **Single-Copy Compaction**\\n\\nThe current compaction strategy is that each BE is carried out separately. In subsequent versions, we will implement single-copy compaction, and realize compaction tasks by cloning snapshots, reduce system load while reducing about 2/3 compaction tasks of the cluster, leaving more system resources to the user side."},{"id":"/release-1.1.1","metadata":{"permalink":"/blog/release-1.1.1","source":"@site/blog/release-1.1.1.md","title":"Apache Doris announced the official release of version 1.1.1","description":"\x3c!--","date":"2022-07-29T00:00:00.000Z","formattedDate":"July 29, 2022","tags":[{"label":"Release Notes","permalink":"/blog/tags/release-notes"}],"truncated":false,"authors":[{"name":"Luzhijing"}],"frontMatter":{"title":"Apache Doris announced the official release of version 1.1.1","summary":"Dear community, we are pleased to announce that we have officially released Apache Doris 1.1.1 on July 29, 2022! This release is a hotfix version of 1.1.0","date":"2022-07-29","author":"Luzhijing","tags":["Release Notes"]},"prevItem":{"title":"How Flink\'s real-time writes to Apache Doris ensure both high throughput and low latency","permalink":"/blog/Flink-realtime-write"},"nextItem":{"title":"Best Practice of Apache Doris in JD","permalink":"/blog/jd"}},"content":"\x3c!--\\nLicensed to the Apache Software Foundation (ASF) under one\\nor more contributor license agreements.  See the NOTICE file\\ndistributed with this work for additional information\\nregarding copyright ownership.  The ASF licenses this file\\nto you under the Apache License, Version 2.0 (the\\n\\"License\\"); you may not use this file except in compliance\\nwith the License.  You may obtain a copy of the License at\\n\\n  http://www.apache.org/licenses/LICENSE-2.0\\n\\nUnless required by applicable law or agreed to in writing,\\nsoftware distributed under the License is distributed on an\\n\\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\nKIND, either express or implied.  See the License for the\\nspecific language governing permissions and limitations\\nunder the License.\\n--\x3e\\n\\n## Features\\n\\n### Support ODBC Sink in Vectorized Engine.\\n\\nThis feature is enabled in non-vectorized engine but it is missed in vectorized engine in 1.1. So that we add back this feature in 1.1.1.\\n\\n### Simple Memtracker for Vectorized Engine.\\n\\nThere is no memtracker in BE for vectorized engine in 1.1, so that the memory is out of control and cause OOM. In 1.1.1, a simple memtracker is added to BE and could control the memory and cancel the query when memory exceeded.\\n\\n## Improvements\\n\\n### Cache decompressed data in page cache.\\n\\nSome data is compressed using bitshuffle and it costs a lot of time to decompress it during query. In 1.1.1, doris will decompress the data that encoded by bitshuffle to accelerate query and we find it could reduce 30% latency for some query in ssb-flat.\\n\\n## Bug Fix\\n\\n### Fix the problem that could not do rolling upgrade from 1.0.(Serious)\\n\\nThis issue was introduced in version 1.1 and may cause BE core when upgrade BE but not upgrade FE.\\n\\nIf you encounter this problem, you can try to fix it with [#10833](https://github.com/apache/doris/pull/10833).\\n\\n### Fix the problem that some query not fall back to non-vectorized engine, and BE will core.\\n\\nCurrently, vectorized engine could not deal with all sql queries and some queries (like left outer join) will use non-vectorized engine to run. But there are some cases not covered in 1.1. And it will cause be crash.\\n\\n### Compaction not work correctly and cause -235 Error.\\n\\nOne rowset multi segments in uniq key compaction, segments rows will be merged in generic_iterator but merged_rows not increased. Compaction will failed in check_correctness, and make a tablet with too much versions which lead to -235 load error.\\n\\n### Some segment fault cases during query.\\n\\n[#10961](https://github.com/apache/doris/pull/10961) \\n[#10954](https://github.com/apache/doris/pull/10954) \\n[#10962](https://github.com/apache/doris/pull/10962)\\n\\n# Thanks\\n\\nThanks to everyone who has contributed to this release:\\n\\n```\\n@jacktengg\\n@mrhhsg\\n@xinyiZzz\\n@yixiutt\\n@starocean999\\n@morrySnow\\n@morningman\\n@HappenLee\\n```"},{"id":"/jd","metadata":{"permalink":"/blog/jd","source":"@site/blog/jd.md","title":"Best Practice of Apache Doris in JD","description":"\x3c!--","date":"2022-07-20T00:00:00.000Z","formattedDate":"July 20, 2022","tags":[{"label":"Best Practice","permalink":"/blog/tags/best-practice"}],"truncated":false,"authors":[{"name":"Apache Doris"}],"frontMatter":{"title":"Best Practice of Apache Doris in JD","summary":"This paper mainly discusses how to use Doris for business exploration and practice in the multi-dimensional analysis of real-time and offline data in the large real-time screen of JD customer service in the scenarios of manual consultation, customer event list, after-sales service list, etc.","date":"2022-07-20","author":"Apache Doris","tags":["Best Practice"]},"prevItem":{"title":"Apache Doris announced the official release of version 1.1.1","permalink":"/blog/release-1.1.1"},"nextItem":{"title":"Best Practice of Apache Doris in Meituan","permalink":"/blog/meituan"}},"content":"\x3c!-- \\nLicensed to the Apache Software Foundation (ASF) under one\\nor more contributor license agreements.  See the NOTICE file\\ndistributed with this work for additional information\\nregarding copyright ownership.  The ASF licenses this file\\nto you under the Apache License, Version 2.0 (the\\n\\"License\\"); you may not use this file except in compliance\\nwith the License.  You may obtain a copy of the License at\\n\\n  http://www.apache.org/licenses/LICENSE-2.0\\n\\nUnless required by applicable law or agreed to in writing,\\nsoftware distributed under the License is distributed on an\\n\\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\nKIND, either express or implied.  See the License for the\\nspecific language governing permissions and limitations\\nunder the License.\\n--\x3e\\n\\n# **Introduction\uff1a**\\n\\n\\n\\nApache Doris is an open source MPP analytical database product that not only can get query results in sub-second response time, effectively supporting real-time data analysis, but also supports huge data sets of more than 10PB. Compared with other industry-hot OLAP database systems, the distributed architecture of Apache is very simple. Itsupports elastic scaling and is easy to operate and maintain, saving a lot of labor and time costs. At present, the domestic community is very popular , and there are also many companies which have large scale uses, such as Meituan and Xiaomi,etc. \\n\\n\\n\\nThis paper mainly discusses how to use Doris for business exploration and practice in the multi-dimensional analysis of real-time and offline data in the large real-time screen of JD customer service in the scenarios of manual consultation, customer event list, after-sales service list, etc.\\n\\n\\n\\nIn recent years, with the explosive growth of data volume and the emergence of the demand for online analysis of massive data, traditional relational databases such as MySQL and Oracle have encountered bottlenecks under large data volume, while databases such as Hive and Kylin lack timeliness. So Apache Doris, Apache Druid, ClickHouse and other real-time analytic databases begun to appear, not only to cope with the second-level queries of massive data, but also to meet the real-time and quasi-real-time analysis needs. Offline and real-time computing engines are in full bloom. But for different scenarios and facing different problems, no single engine is a panacea. We hope that this article can give you some inspiration on the application and practice of offline and real-time analytics in JD\'s customer service business, and we hope you will communicate more and give us valuable suggestions.\\n\\n# **JD Customer Service Business Form**\\n\\n\\n\\nAs the entrance to the group\'s services, JD Customer Service provides efficient and reliable protection for users and merchants. JD customer service is responsible for solving users\' problems in a timely manner and providing them with detailed and easy-to-understand instructions and explanations; in order to better understand users\' feedback and the status of products, it is necessary to monitor a series of indicators such as the number of inquiries, pick-up rates, complaints, etc. in real time, and discover problems in a timely manner through ring comparison and year-on-year comparison, in order to better adapt to users\' shopping styles, improve service quality and efficiency, and thus enhance the brand of JD influence.\\n\\n\\n\\n# **Easy OLAP Design**\\n\\n\\n\\n### **01 EasyOLAP Doris Data Import Links**\\n\\n\\n\\nEasyOLAP Doris data sources are mainly real-time Kafka and offline HDFS files. The import of real-time data relies on Routine Load; offline data is mainly imported using Broker Load and Stream Load.\\n\\n\\n\\n![1280X1280](/images/jd03.png)\\n\\n\\n\\nEasyOLAP Doris Data Import Links\\n\\n\\n\\n### **02 EasyOLAP Doris Full Link Monitor**\\n\\n\\n\\nThe EasyOLAP Doris project currently uses the Prometheus + Grafana framework for monitoring. The node_exporter is responsible for collecting machine-level metrics, and Doris automatically spits out FE and BE service-level metrics in Prometheus format. In addition, OLAP Exporter service is deployed to collect Routine Load related metrics, aiming to discover real-time data stream import at the first time and ensure real-time data timeliness.\\n\\n\\n\\n![EasyOLAP Doris monitoring link](/images/jd04.png)\\n\\n\\n\\nEasyOLAP Doris monitoring link\\n\\n![640](/images/jd01.png)\\n\\n### **03 EasyOLAP Doris Primary-Secondary Dual Stream Design**\\n\\n\\n\\nEasyOLAP Doris adopts a dual-write approach for the primary and secondary clusters in order to guarantee the service stability of Level 0 services during the promotion time.\\n\\n\\n\\n![03 EasyOLAP Doris Primary-Secondary Dual Stream Design](/images/jd02.png)\\n\\n\\n\\nEasyOLAP Doris Primary-Secondary Dual Stream Design\\n\\n\\n\\n### **04 EasyOLAP Doris Dynamic Partition Management**\\n\\n\\n\\nAfter analyzing the requirements, the JD OLAP team did some customization of Doris, which involved dynamic partition management. Although the community version already had the function of dynamic partitioning, the function could not retain partitions of a specified time. For the characteristics of JD Group, we have retained historical data of specified time, such as data during 618 and 11.11, which will not be deleted due to dynamic partitioning. The dynamic partition management feature can control the amount of data stored in the cluster, and it is easy to use by the business side without the need to manage partition information manually or with additional code.\\n\\n\\n\\n# **Doris Caching Mechanism**\\n\\n\\n\\n### **01 Demand Scenarios**\\n\\n\\n\\nCommitted to continuously improving user experience, JD Customer Service\'s data analysis pursues the ultimate timeliness. Offline data analysis scenario is write less read more, data is written once and read frequently many times; real-time data analysis scenario, part of the data is not updated historical partition, part of the data is in the updated partition. In most analysis applications, there are the following scenarios:\\n\\n- High concurrency scenario: Doris better support high concurrency, but too high QPS will cause cluster jitter, and a single node can not carry too high QPS;.\\n\\n- Complex queries: JD customer service real-time operation platform monitoring needs to display multi-dimensional complex indicators according to business scenarios, rich indicators display corresponding to a variety of different queries, and data sources from multiple tables . Although the response time of individual queries at milliseconds level , the overall response time may be at the second level.\\n\\n- Repeated queries: if there is no anti-refresh mechanism, repeatedly refreshing the page will lead to the submission of a large number of repeated queries due to delays or hand errors.\\n\\nFor the above scenario, there are solutions at the application layer \u2014\u2014 the query results are put into Redis and the cache is refreshed periodically or manually by the user, but there are some problems\uff1a\\n\\n- Data inconsistency: can not respond immediately to data updates, and the user may receive results with old data.\\n\\n- Low hit rate: if the data is highly real-time and the cache is frequently invalidated, the hit rate of the cache is low and the load on the system cannot be relieved.\\n\\nAdditional cost: introduction of external components increases system complexity and adds additional cost.\\n\\n\\n\\n### **02 Introduction to Caching Mechanism**\\n\\n\\n\\nThere are three different types of Cache in EasyOLAP Doris, respectively Result Cache, SQL Cache and Partition Cache, depending on the applicable scenario. All three types of caches can be switched on and off by MySQL client commands.\\n\\nThese three caching mechanisms can coexist: which can be turned on at the same time. When querying, the query parser first determines whether the Result Cache is enabled or not, and if the Result Cache is enabled, it first finds out whether the cache exists for the query from the Result Cache, and if the cache fails or does not exist, it directly takes the cached value and returns it to the client. The cache is placed in the memory of each FE node for fast reading.\\n\\nSQL Cache stores and gets the cache according to the signature of SQL, the ID of the partition of the queried table, and the latest version number of the partition. These three together serve as cache conditions. If one of these three conditions is changed, such as SQL statement change or partition version number change after data update, the cache will not be hit. In the case of multiple table joins, the partition update of one of the tables will also result in failure to hit the cache. SQL Cache is more suitable for T+1 update scenarios.\\n\\nPartition Cache is a more fine-grained caching mechanism. Partition cache mainly splits a query into read-only partition and updatable partition in parallel based on partition, read-only partition is cached, updatable partition is not cached, and the corresponding result set is generated n, and then the results of each split subquery are merged. Therefore, if the query N days of data, data update the most recent D days, each day is only a different date range but similar queries, you can use Partition Cache, only need to query D partitions can be, the other parts are from the cache, can effectively reduce the cluster load, shorten the query response time.\\n\\nWhen a query enters Doris, the system will first process the query statement and take it as the key, before executing the query statement, the query analyzer can automatically select the most suitable caching mechanism to ensure that the caching mechanism is used to shorten the query response time in the best case. Then, it checks whether the query result exists in the Cache, and if it does, it gets the data in the cache and returns it to the client; if it does not, it queries normally and stores the query result as Value and the query statement Key in the cache. SQL Cache is more suitable for T+1 scenarios and works well when partition updates are infrequent and SQL statements are repetitive Partition Cache is the least granular cache. When a query statement queries data for a time period, the query statement is split into multiple subqueries. It can shorten the query time and save cluster resources when the data is written to only one partition or partial partition.\\n\\nTo better observe the effectiveness of caching, metrics have been added to Doris\' service metrics, which are monitored visually through Prometheus and Grafana monitoring systems. The metrics include the number of hits for different types of Cache, the hit rate for different types of Cache, the memory size of the Cache, and other metrics.\\n\\n\\n\\n### **03 Caching Mechanism Effect**\\n\\n\\n\\nFor the JD Customer Service Doris main cluster, some services reached 100% CPU usage during 11.11 period without caching on; with Result Cache on, CPU usage was between 30% and 40%. The caching mechanism ensures that the business can get the query results quickly and protects the cluster resources well under high concurrency scenarios.\\n\\n\\n\\n# **Doris\' optimization during the 11.11 sale, 2020**\\n\\n\\n\\n### **01 Import Task Optimization**\\n\\n\\n\\nThe import of real-time data has always been a challenge. Among them, ensuring real-time data and importing stability is the most important. In order to observe the real-time data import situation more intuitively, JD OLAP team developed OLAP Exporter independently to collect real-time data import-related metrics, such as import speed, import backlog and suspended tasks. The import speed and import backlog can be used to determine the status of a real-time import task, and if find a trend of backlog, the sampling tool developed independently can be used to sample and analyze the real-time task. Real-time tasks have three main thresholds to control the submission of tasks, which are the maximum processing interval per batch, the maximum number of processing entries per batch and the maximum amount of data processed per batch, and a task will be submitted as soon as one of these thresholds is reached. By increasing the logs, we found that the task queue in FE was relatively busy, so the parameters were mainly adjusted to make the maximum number of processing entries per batch and the maximum amount of data processed per batch larger, and then the maximum processing interval per batch was adjusted to ensure that the data latency was within twice the maximum processing interval per batch according to the business requirements. Through the sampling tool, the analysis task ensures not only the real-time data, but also the stability of the import. In addition, we also set up alarms to detect abnormalities such as backlog of real-time import tasks and suspension of import tasks in a timely manner.\\n\\n\\n\\n### **02 Monitoring Metrics Optimization**\\n\\n\\n\\nThe monitoring metrics are divided into two main sections, a machine level metrics section and a business level metrics section. In the whole monitoring panel, detailed metrics bring comprehensive data and at the same time make it more difficult to get important metrics. So, to get a better view of important metrics for all clusters, a separate panel is created - 11.11 Important Metrics Summary Panel. The board contains metrics such as BE CPU usage, real-time task consumption backlog rows, TP99, QPS, and so on. The number of metrics is small, but the situation of all clusters can be observed, which can eliminate the trouble of frequent switching in monitoring.\\n\\n\\n\\n### **03 Peripheral Tools Support**\\n\\n\\n\\nIn addition to the sampling tools and OLAP Exporter mentioned above, the JD OLAP team has also developed a series maintenance tools for Doris.\\n\\n\\n\\n1. Import sampling tool: The import sampling tool not only collects the data imported in real time, but also supports adjusting the parameters of the real time import task, or generating creation statements (including the latest loci and other information) for task migration and other operations when the real time import task is paused.\\n\\n   \\n\\n2. Big query tool: Big queries not only cause jitter in cluster BE CPU usage, but also lead to longer response time for other queries. Before the Big Query tool, if you found jitter in cluster CPU, you needed to check the audit logs on all FEs and then do the statistics, which is not only time-consuming but also not intuitive. The Big Query tool is designed to solve the above problem. When the monitoring side finds that the cluster has jitter, you can use the Big Query tool and enter the cluster name and time point to get the total number of queries for different services at that time point, the number of queries with more than 5 seconds, 10 seconds, 20 seconds, the number of queries with huge scanning volume, etc. It is convenient for us to analyze the big queries from different dimensions. The details of the big queries will also be saved in the intermediate file, which can directly get the big queries of different businesses. The whole process only takes a few tens of seconds to a minute to locate the big query that is happening and get the corresponding query statements, which greatly saves time and operation and maintenance costs.\\n\\n   \\n\\n3. Downgrade and recovery tools: In order to ensure the stability of the Level 0 business during the 11.11 promotion, when the cluster pressure exceeds the safety level, it is necessary to downgrade other non-Level 0 businesses, and then restore them to the pre-downgrade settings with one click after the peak period. The degradation mainly involves reducing the maximum number of connections to the service, suspending non-level 0 real-time import tasks, and so on. This greatly increases the ease of operation and improves efficiency.\\n\\n   \\n\\n4. Cluster inspection tool: During 11.11 period, the health inspection of clusters is extremely important. Routine inspections include primary and secondary cluster consistency checks for dual-stream services. In order to ensure that the business can quickly switch to the other cluster when one cluster has problems, it is necessary to ensure that the library tables on both clusters are consistent and the data volume is not too different; check whether the number of copies of the library tables is 3 and whether there are unhealthy Tablet in the cluster; check the machine disk utilization, memory and other machine-level indicators, etc. Check the machine disk utilization, memory and other machine-level metrics, etc.\\n\\n   \\n\\n   # **Summary & Outlook**\\n\\n   \\n\\n   JD Customer Service was introduced to Doris in early 2020, and currently has one standalone cluster and one shared cluster, and is an experienced user of JD OLAP.\\n\\n   \\n\\n   In the business use, we also encountered problems such as task scheduling-related, import task configuration-related and query-related problems, which are driving the JD OLAP team to understand Doris more deeply. We plan to promote the use of materialized views to further improve the efficiency of queries; use Bitmap to support accurate de-duplication of UV and other metrics; use audit logs to make it easier to count large and slow queries; and solve the scheduling problem of real-time import tasks to make them more efficient and stable. In addition, we also plan to optimize table building, create high-quality Rollup or materialized views to improve the smoothness of the application, and accelerate more businesses to the OLAP platform to improve the impact of the application."},{"id":"/meituan","metadata":{"permalink":"/blog/meituan","source":"@site/blog/meituan.md","title":"Best Practice of Apache Doris in Meituan","description":"\x3c!--","date":"2022-07-20T00:00:00.000Z","formattedDate":"July 20, 2022","tags":[{"label":"Best Practice","permalink":"/blog/tags/best-practice"}],"truncated":false,"authors":[{"name":"Apache Doris"}],"frontMatter":{"title":"Best Practice of Apache Doris in Meituan","summary":"Introduction: This paper mainly introduces a general method and practice of real-time data warehouse construction. The real-time data warehouse aims at end-to-end low latency, SQL standardization, rapid response to changes, and data unification. In practice, the best practice we summarize is: a common real-time production platform + a common interactive real-time analysis engine cooperate with each other to meet real-time and quasi-real-time business scenarios. The two have a reasonable division of labor and complement each other to form an easy-to-develop, easy-to-maintain, and most efficient assembly line, taking into account development efficiency and production costs, and satisfying diverse business needs with a better input-output ratio.","date":"2022-07-20","author":"Apache Doris","tags":["Best Practice"]},"prevItem":{"title":"Best Practice of Apache Doris in JD","permalink":"/blog/jd"},"nextItem":{"title":"Best Practice of Apache Doris in Xiaomi Group","permalink":"/blog/xiaomi"}},"content":"\x3c!-- \\nLicensed to the Apache Software Foundation (ASF) under one\\nor more contributor license agreements.  See the NOTICE file\\ndistributed with this work for additional information\\nregarding copyright ownership.  The ASF licenses this file\\nto you under the Apache License, Version 2.0 (the\\n\\"License\\"); you may not use this file except in compliance\\nwith the License.  You may obtain a copy of the License at\\n\\n  http://www.apache.org/licenses/LICENSE-2.0\\n\\nUnless required by applicable law or agreed to in writing,\\nsoftware distributed under the License is distributed on an\\n\\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\nKIND, either express or implied.  See the License for the\\nspecific language governing permissions and limitations\\nunder the License.\\n--\x3e\\n\\n# Best Practice of Apache Doris in Meituan\\n\\nIntroduction: This paper mainly introduces a general method and practice of real-time data warehouse construction. The real-time data warehouse aims at end-to-end low latency, SQL standardization, rapid response to changes, and data unification. In practice, the best practice we summarize is: a common real-time production platform + a common interactive real-time analysis engine cooperate with each other to meet real-time and quasi-real-time business scenarios. The two have a reasonable division of labor and complement each other to form an easy-to-develop, easy-to-maintain, and most efficient assembly line, taking into account development efficiency and production costs, and satisfying diverse business needs with a better input-output ratio.\\n\\n# real-time scene\\n\\nThere are many scenarios in which real-time data is delivered in Meituan, mainly including these following points:\\n\\n- Operational level: Such as real-time business changes, real-time marketing effects, daily business status and daily real-time business trend analysis, etc.\\n- Production level: such as whether the real-time system is reliable, whether the system is stable, real-time monitoring of the health of the system, etc.\\n- C-end users: For example, search recommendation sorting requires real-time understanding of users\' thoughts, behaviors and characteristics, and recommendation of more concerned content to users.\\n- Risk control: Food delivery and financial technology are used a lot. Real-time risk identification, anti-fraud, abnormal transactions, etc., are all scenarios where a large number of real-time data are applied\\n\\n# Real-time technology and architecture\\n\\n### 1.Real-time computing technology selection\\n\\nAt present, there are many open source real-time technologies, among which Storm, Spark Streaming and Flink are common. The specific selection depends on the business situation of different companies.\\n\\nMeituan Takeaway relies on the overall construction of meituan\'s basic data system. In terms of technology maturity, It used Storm a few years ago, which was irreplaceable in terms of performance stability, reliability and scalability. As Flink becomes more and more mature, it has surpassed Storm in terms of technical performance and framework design advantages. In terms of trends, just like Spark replacing MR, Storm will be gradually replaced by Flink. Of course, there will be a process of migrating from Storm to Flink. We currently have some old tasks still on Storm, and we are constantly promoting task migration.\\n\\nThe comparison between Storm and Flink can refer to the form above.\\n\\n### 2.Real-time Architecture\\n\\n#### \u2460 Lambda Architecture\\n\\nThe Lambda architecture is a relatively classic architecture. In the past, there were not many real-time scenarios, mainly offline. When a real-time scene is attached, the technical ecology is different due to the different timeliness of offline and real- time. The Lambda architecture is equivalent to attaching a real-time production link, which is integrated at the application level, and two-way production is independent of each other.This is also a logical approach to adopt in business applications.\\n\\nThere will be some problems in dual-channel production, such as double processing logic, double development and operation and maintenance, and resources will also become two resource links. Because of these problems,  Kappa architecture has been evolved.\\n\\n#### \u2461 Kappa Architecture\\n\\nThe Kappa architecture is relatively simple in terms of architecture design, unified in production, and a set of logic produces both offline and real time. However, there are relatively large limitations in practical application scenarios. There are few cases in the industry that directly use the Kappa architecture for production and implementation,  and the scene is relatively simple. These problems will also be encountered on our side, and we will also have some thoughts of our own, which will be discussed later.\\n\\n# Business Pain Points\\n\\nIn the take-away business, we also encountered some problems.\\n\\nIn the early stage of the business, in order to meet the business needs, the requirements are generally completed case by case after the requirements are obtained. The business has high real-time requirements. From the perspective of timeliness, there is no opportunity for middle-level precipitation. In the scenario, the business logic is generally directly embedded. This is a simple and effective method that can be imagined. This development mode is relatively common in the early stage of business development.\\n\\nAs shown in the figure above, after getting the data source, it will go through data cleaning, dimension expansion, business logic processing through Storm or Flink, and finally direct business output. Taking this link apart, the data source will repeatedly refer to the same data source, and the operations such as cleaning, filtering, and dimension expansion must be repeated. The only difference is that the code logic of the business is different. IIf there is less business, this model is acceptable, but when the subsequent business volume increases, there will be a situation where whoever develops will be responsible for operation and maintenance, the maintenance workload will increase, and the operations cannot be managed in a unified manner. Moreover, everyone is applying for resources, resulting in a rapid expansion of resource costs, and resources cannot be used intensively and effectively. Therefore, it is necessary to think about how to construct real-time data from the whole data source.\\n\\n# Data features and Application Scenario\\n\\nSo how to build a real-time data warehouse?\\n\\nFirst of all, we need to disassemble this task into what data, what scenarios, and what features these scenarios have in common. For takeaway business scenarios, there are two categories, log class and business category.\\n\\n- Log class: It is characterized by a large amount of data, semi-structured, and deeply nested.Log data has a great feature that once the log stream is formed, it will not change. It will collect all the logs of the platform by means of buried points, and then collect and distribute them uniformly. Just like a tree with really large roots.  The whole process of pushing to the front-end application is just like the process of a tree branching from the root to a branch (the decomposition process from 1 to n). If all businesses search for data from the root, although the path seems to be the shortest, because of the heavy burden,the data retrieval efficiency is low. Log data is generally used for production monitoring and user behavior analysis. The timeliness requirements are relatively high . Generally, the  time window will be 5 minutes or 10 minutes, or up to the current state. The main application is the real-time large screen and real-time features, such as behaviour can immediately perceive the need for waiting every time the user clicks.\\n\\n- Business category: The business class is mainly about business transaction data. Business systems are usually self-contained and distribute data down in the form of Binlog logs. All business systems are transactional, mainly using paradigm modeling methods, which have a structured characteristic and the main part can be seen clearly. However, due to the large number of data tables, multi-table associations are required to express the complete business. So it\'s an integrated machining process from n to 1 .\\n\\nSeveral difficulties faced by business real-time processing:\\n\\n- Diversity of business: Business processes are constantly changing from the beginning to the end, such as from ordering -> payment -> delivery. The business database is changed  on the original basis,and Binlog will generate a lot of changed logs. Business analysis is more focused on the end state, which leads to the problem of data retraction calculation, such as placing an order at 10 o\'clock and canceling it at 13 o\'clock, but hoping to subtract the canceled order at 10 o\'clock.\\n\\n- Business integration: Business analysis data usually cannot be expressed by a single subject, and often many tables are associated to obtain the desired information. When confluent alignment of data is performed in real-time streaming, it often requires large cache processing and is complicated.\\n\\n- The analysis is batch, and the processing process is streaming: for a single data, no analysis can be formed, so the analysis object must be batch, and the data processing is one by one.\\n\\nThe scenarios of log classes and business classes generally exist at the same time and are intertwined. Whether it is Lambda architecture or Kappa architecture, a single application will have some problems, so it is more meaningful to choose the architecture and practice according to the scenario.\\n\\n# Architecture Design of Real-time Data Warehouse\\n\\n### 1.Real-time Architecture: Exploration of Stream-Batch Combination\\n\\nBased on the above problems, we have our own thinking and ideas\uff0cit is to deal with different business scenarios through the combination of flow and batch.\\n\\nAs shown in the figure above, the data is collected from the log to the message queue, and then to the ETL process of the data stream. The construction of the basic data stream is unified. Afterwards, for log real-time features, real-time large-screen applications use real-time stream computing. Real-time OLAP batch processing is used for Binlog business analysis.\\n\\nWhat are the Pain Points of Stream Processing Analysis Business? For the paradigm business, both Storm and Flink require a large amount of external memory to achieve business alignment between data streams, which requires a lot of computing resources. Due to the limitation of external memory, the window limitation strategy must be carried out, and may eventually discard some data as a result. After calculation, it is generally stored in Redis as query support, and KV storage has many limitations in dealing with analytical query scenarios.\\n\\nHow to achieve real-time OLAP? Is there a real-time computing engine with its own storage, when the real-time data is entered,it can flexibly and freely calculate within a certain range, and has a certain data carrying capacity, and supports analysis of query responses at the same time? With the development of technology, the current MPP engine is developing very rapidly, and its performance is also improving rapidly, so there is a new possibility in this scenario, just like the Doris engine we use here.\\n\\nThis idea has been practiced in the industry and has become an important exploration direction. For example, Alibaba\'s real-time OLAP solution based on ADB, etc.\\n\\n### 2.Architecture Design of Real-time Data Warehouse\\n\\nFrom the perspective of the entire real-time data warehouse architecture, the first thing to consider is how to manage all real-time data, how to effectively integrate resources, and how to construct data.\\n\\nIn terms of methodology, the real-time and offline are very similar to each other. In the early stage of offline data warehouse, it is also case by case. Consider how to govern it when the scale of data increases to a certain amount. We all know that layering is a very effective way of data governing. So, on the issue of how to manage the real-time data warehouse, the first consideration is also the hierarchical processing logic, as follows:\\n\\n- Data source: At the data source level, offline and real-time data sources are consistent. They are mainly divided into log classes and business classes. Log classes include user logs, DB logs, and server logs.\\n\\n- Real-time detail layer: At the detail level, in order to solve the problem of repeated construction, a unified construction should be carried out.Using the offline data warehouse model to build a unified basic detailed data layer, managed according to the theme, the purpose of the detail layer is to provide directly available data downstream, so the basic layer should be processed uniformly, such as cleaning, filtering, and dimension expansion.\\n\\n- Aggregation layer: The summary layer can directly calculate the result through the concise operator of Flink or Storm. And form a summary of indicators, all indicators are processed at the summary layer, and everyone manages and constructs according to unified specifications, forming a reusable summary result.\\n\\nIn conclusion, from the perspective of the construction of the entire real-time data warehouse,first of all, the data construction needs to be layered, build the framework first, and set the specifications includs  what extent each layer is processed and how each layer is used.The definition of specifications facilitates standardized processing in production.Due to the need to ensure timeliness, don\'t design too many layers when designing.For scenarios with high real-time requirements, you can basically refer to the left side of the figure above. For batch processing requirements, you can import from the real-time detail layer to the real-time OLAP engine, and perform fast retraction calculations based on the OLAP engine\'s own calculation and query capabilities, as shown in the data flow on the right side of the figure above.\\n\\n# Real-time platform construction\\n\\nAfter the architecture is determined, the next consideration is how to build a platform.The construction of the real-time platform is completely attached to the real-time data warehouse management.\\n\\nFirst, abstract the functions and abstract them into components, so that standardized production can be achieved, and systematic guarantees can be further constructed. For the basic processing layer cleaning, filtering, confluence, dimension expansion, conversion, encryption, screening and other functions can be abstracted, and the base layer builds a directly usable data result stream in this componentized way. How to meet diverse needs and how to be compatible with users are the problems that we need to figure out. In this case it may occur problems with redundant processing. In terms of storage, real-time data does not have a history and will not consume too much storage. This redundancy is acceptable.The production efficiency can be improved by means of redundancy, which is an ideological application of changing space for time.\\n\\nThrough the processing of the base layer, all data is deposited in the IDL layer, and written to the base layer of the OLAP engine at the same time, and then the real-time summary layer is calculated. Based on Storm, Flink or Doris, multi-dimensional summary indicators are produced to form a unified summary layer for unified storage distribution.\\n\\nWhen these functions are available, system capabilities such as metadata management, indicator management, data security, SLA, and data quality will be gradually built.\\n\\n### 1.Real-time base layer functions\\n\\nThe construction of the real-time base layer needs to solve some problems.\\n\\nThe first is the problem of repeated reading of a stream. When a Binlog is called, it exists in the form of a DB package. Users may only use one of the tables. If everyone wants to use it, there may be a problem that everyone needs to access this stream. The solution can be deconstructed according to different businesses, restored to the basic data flow layer, made into a paradigm structure according to the needs of the business, and integrated with the theme construction according to the modeling method of the data warehouse.\\n\\nSecondly, we need to encapsulate components, such as basic layer cleaning, filtering, and dimension expansion . Users can write logic by a very simple expression. Trans part is more flexible. For example, converting from one value to another value, for this custom logic expression, we also open custom components, which can develop custom scripts through Java or Python for data processing.\\n\\n### 2.Real-time feature production capabilities\\n\\nFeature production can be expressed logically through SQL syntax, and the underlying logic is adapted, and transparently transmitted to the computing engine, shielding the user\'s dependence on the computing engine.Just like for offline scenarios, currently large companies rarely develop through code, unless there are some special cases, so they can basically be expressed in SQL.\\n\\nAt the functional level, the idea of indicator management is integrated. Atomic indicators, derived indicators, standard calculation apertures, dimension selection, window settings and other operations can be configured in a configurable way.In this way, the production logic can be uniformly parsed and packaged uniformly.\\n\\nAnother question,with the same source code a lot of SQL is written, and each submission will have a data stream which is a waste of resources.Our solution is to produce dynamic metrics through the same data stream, so that metrics can be added dynamically without stopping the service.\\n\\nSo, during the construction of the real-time platform, engineers should consider more about how to use resources more effectively and which links can use resources more economically.\\n\\n### 3.SLA construction\\n\\nSLA mainly solves two problems, one is about the end-to-end SLA, the other is  about the SLA of job productivity. We adopt the method of burying points + reporting.Because the real-time stream is relatively large, the burying point should be as simple as possible, do not bury too many things,can express the business information is enough.The output of each job is reported to the SLA monitoring platform in a unified manner, and the required information is reported at each job point through a unified interface, and finally the end-to-end SLA can be counted.\\n\\nIn real-time production, because the process is very long, it is impossible to control all links, but it can control the efficiency of its own operations, so job SLA is also essential.\\n\\n### 4.Real-time OLAP solution\\n\\nProblems:\\n\\n- Binlog business restoration is complex\uff1aThere are many changes in the business, and changes at a certain point in time are required. Therefore, sorting and data storage are required, which consumes a lot of memory and CPU resources.\\n\\n- Binlog business association is complex\uff1aIn stream computing, the relationship between streams and streams is very difficult to express business logic.\\n\\nsolutions\uff1a\\n\\nTo solve the problem through the OLAP engine with computing power, there is no need to logically map a data stream, and only the problem of real-time and stable data storage needs to be solved.\\n\\nWe use Doris as a high-performance OLAP engine here.Due to the need for derivative calculations between the results generated by the business data and the results, Doris can quickly restore the business by using the unique model or the aggregation model, and can also perform aggregation at the summary layer while restoring the business,and is also designed for reuse.The application layer can be physical or logical view.\\n\\nThis mode focuses on solving the business rollback calculation. For example, when the business state changes, the value needs to be changed at a certain point in history. The cost of using flow calculation in this scenario is very high. The OLAP mode can solve this problem very well.\\n\\n# Real-time use cases\\n\\nIn the end, we use a case to illustrate.For example, merchants want to offer discounts to users based on the number of historical orders placed by users. Merchants need to see how many orders they have placed in history. They must have historical T+1 data and real-time data today.This scenario is a typical Lambda architecture,You can design a partition table in Doris, one is the historical partition, and the other is the today partition. The historical partition can be produced offline. Today\'s indicators can be calculated in real time and written to today\'s partition. When querying, a simple summary.\\n\\nThis scenario seems relatively simple, but the difficulty lies in the fact that many simple problems will become complicated after the number of merchants increases.Therefore, in the future, we will use more business input to precipitate more business scenarios, abstract them to form a unified production plan and function, and support diversified business needs with minimized real-time computing resources, which is also what needs to be achieved in the future. \\n\\nThat\'s all for today, thank you.\\n\\n### about the author:\\n\\nZhu Liang, more than 5 years experience in data warehouse construction in traditional industries, 6 years experience in Internet data warehouse, technical direction involves offline, real-time data warehouse management, systematic capacity building, OLAP system and engine, big data related technologies, focusing on OLAP,and real-time technology frontier development trends.The business direction involves ad hoc query, operation analysis, strategy report product, user portrait, crowd recommendation, experimental evaluation, etc."},{"id":"/xiaomi","metadata":{"permalink":"/blog/xiaomi","source":"@site/blog/xiaomi.md","title":"Best Practice of Apache Doris in Xiaomi Group","description":"\x3c!--","date":"2022-07-20T00:00:00.000Z","formattedDate":"July 20, 2022","tags":[{"label":"Best Practice","permalink":"/blog/tags/best-practice"}],"truncated":false,"authors":[{"name":"Apache Doris"}],"frontMatter":{"title":"Best Practice of Apache Doris in Xiaomi Group","summary":"In order to improve the query performance of the Xiaomi growth analysis platform and reduce the operation and maintenance costs, Xiaomi Group introduced Apache Doris in September 2019. In the past two and a half years, **Apache Doris has been widely used in Xiaomi Group,** **such as business growth analytic platform, realtime dashboards for all business groups,  finance analysis, user profile analysis, advertising reports, A/B testing platform and so on.** This article will share the best practice of Apache Doris in Xiaomi Group.","date":"2022-07-20","author":"Apache Doris","tags":["Best Practice"]},"prevItem":{"title":"Best Practice of Apache Doris in Meituan","permalink":"/blog/meituan"},"nextItem":{"title":"Apache Doris announced the official release of version 1.1","permalink":"/blog/1.1 Release"}},"content":"\x3c!-- \\nLicensed to the Apache Software Foundation (ASF) under one\\nor more contributor license agreements.  See the NOTICE file\\ndistributed with this work for additional information\\nregarding copyright ownership.  The ASF licenses this file\\nto you under the Apache License, Version 2.0 (the\\n\\"License\\"); you may not use this file except in compliance\\nwith the License.  You may obtain a copy of the License at\\n\\n  http://www.apache.org/licenses/LICENSE-2.0\\n\\nUnless required by applicable law or agreed to in writing,\\nsoftware distributed under the License is distributed on an\\n\\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\nKIND, either express or implied.  See the License for the\\nspecific language governing permissions and limitations\\nunder the License.\\n--\x3e\\n\\n\\n# Background\\n\\nIn order to improve the query performance of the Xiaomi growth analysis platform and reduce the operation and maintenance costs, Xiaomi Group introduced Apache Doris in September 2019. In the past two and a half years, **Apache Doris has been widely used in Xiaomi Group,** **such as business growth analytic platform, realtime dashboards for all business groups,  finance analysis, user profile analysis, advertising reports, A/B testing platform and so on.** This article will share the best practice of Apache Doris in Xiaomi Group. \\n\\n# Business Practice\\n\\nThe typical business practices of Apache Doris in Xiaomi are as follows:\\n\\n## 01 User Access\\n\\nData Factory is a one-stop data development platform developed by Xiaomi for data developers and data analysts. This platform supports data sources such as Doris, Hive, Kudu, Iceberg, ES, Talso, TiDB, MySQL, etc. It also supports computing engines such as Flink, Spark,  Presto,etc.\\n\\nInside Xiaomi, users need to access the Doris service through the data factory. Users need to register in the data factory and complete the approval for building the database. The Doris operation and maintenance classmates will connect according to the descriptions of the business scenarios and data usage expectations submitted by users in the data factory. After completing the access approval, users can use the Doris service to perform operations such as visual table creation and data import in the data factory.\\n\\n## 02 Data import\\n\\nIn Xiaomi\'s business, the two most common ways to import data into Doris are Stream Load and Broker Load. User data will be divided into real-time data and offline data, and users\' real-time and offline data will generally be written to Talos first (Talos is a distributed, high-throughput message queue developed by Xiaomi). The offline data from Talos will be sink to HDFS, and then imported to Doris through the data factory. Users can directly submit Broker Load tasks in the data factory to import large batches of data on HDFS into Doris, In addition, you can run the SparkSQL command in the data factory to query data from Hive, Import the data found in SparkSQL into Doris through Spark-doris-Connector, and encapsulate Stream Load at the bottom layer of Spark-doris-Connector. Real-time data from Talos is generally imported into Doris in two ways. One is to first perform ETL on the data through Flink, and then import small batches of data to Doris through.Flink- Doris-connector encapsulates the Stream Load at the bottom layer. Another way is to import small batches of data into Doris through Stream Load encapsulated by Spark Streaming at regular intervals.\\n\\n## 03 Data Query\\n\\nDoris users of Xiaomi generally analyze and query Doris and display the results through the ShuJing platform.ShuJing is a general-purpose BI analysis tool developed by Xiaomi. Users can query and visualize Doris through ShuJing  platform, and realize user behavior analysis (in order to meet the needs of business event analysis, retention analysis, funnel analysis, path analysis and other behavior analysis needs, We added corresponding UDF and UDAF ) and user profile analysis for Doris.\\n\\n## 04 Compaction Tuning\\n\\nFor Doris, each data import will generate a data version under the relevant data shard (Tablet) of the storage layer, and the Compaction mechanism will asynchronously merge the smaller data versions generated by the import (the detailed principle of the Compaction mechanism can be Refer to the previous article \\"Doris Compaction Mechanism Analysis\\").\\n\\nXiaomi has many high-frequency, high-concurrency, near-real-time import business scenarios, and a large number of small versions will be generated in a short period of time. If Compaction does not merge data versions in time, it will cause version accumulation.On the one hand, too many minor versions will increase the pressure on metadata, and on the other hand, too many versions will affect query performance.In Xiaomi\'s usage scenarios, many tables use the Unique and Aggregate data models, and the query performance is heavily dependent on whether Compaction can merge data versions in time.In our business scenario, the query performance was reduced by tens of times due to delayed version merging, thus affecting online services.When a Compaction happens, it consumes CPU, memory, and disk I/O resources. Too much compaction will take up too many machine resources, affect query performance, and may cause OOM.\\n\\n**In response to this problem of Compaction, we first start from the business side and guide users through the following aspects:**\\n\\n- Set reasonable partitions and buckets for tables to avoid generating too many data fragments.\\n\\n- Standardize the user\'s data import operation, reduce the frequency of data import, increase the amount of data imported in a single time, and reduce the pressure of Compaction.\\n\\n- Avoid using delete operations too much.The delete operation will generate a delete version under the relevant data shard in the storage layer.The Cumulative Compaction task will be truncated when the delete version is encountered. This task can only merge the data version after the Cumulative Point and before the delete version, move the Cumulative Point to the delete version, and hand over the delete version to the subsequent Base Compaction task. to process. If you use the delete operation too much, too many delete versions will be generated under the Tablet, which will cause the Cumulative Compaction task to slow down the progress of version merging. Using the delete operation does not actually delete the data from the disk, but records the deletion conditions in the delete version. When the data is queried, the deleted data will be filtered out by Merge-On-Read. Only the delete version is merged by the Base Compaction task. After that, the data to be deleted by the delete operation can be cleared from the disk as expired data with the Stale Rowset. If you need to delete the data of an entire partition, you can use the truncated partition operation instead of the delete operation.\\n\\n**Second, we tuned Compaction from the operation and maintenance side:**\\n\\n- According to different business scenarios, different Compaction parameters (Compaction strategy, number of threads, etc.) are configured for different clusters.\\n\\n- Appropriately lowers the priority of the Base Compaction task and increases the priority of the Cumulative Compaction task, because the Base Compaction task takes a long time to execute and has serious write amplification problems, while the Cumulative Compaction task executes faster and can quickly merge a large number of small versions.\\n\\n- Version backlog alarm, dynamic adjustment of Compaction parameters.When the Compaction Producer produces Compaction tasks, it will update the corresponding metric.It records the value of the largest Compaction Score on the BE node. You can check the trend of this indicator through Grafana to determine whether there is a version backlog. In addition, we have added a Version backlog alert.In order to facilitate the adjustment of Compaction parameters, we have optimized the code level to support dynamic adjustment of the Compaction strategy and the number of Compaction threads at runtime, avoiding the need to restart the process when adjusting the Compaction parameters.\\n\\n- Supports manual triggering of the Compaction task of the specified Table and data shards under the specified Partition, and improves the Compaction priority of the specified Table and data shards under the specified Partition.\\n\\n# Monitoring and Alarm Management\\n\\n## 01 Monitoring System\\n\\nPrometheus will regularly pull Metrics metrics from Doris\'s FE and BE and display them in the Grafana monitoring panel.The service metadata based on QingZhou Warehouse will be automatically registered in Zookeeper, and Prometheus will regularly pull the latest cluster metadata information from Zookeeper and display it dynamically in the Grafana monitoring panel.\uff08Qingzhou Data Warehouse is a data warehouse constructed by the Qingzhou platform based on the operation data of Xiaomi\'s full-scale big data service. It consists of 2 base tables and 30+ dimension tables.Covers the whole process data such as resources, server cmdb, cost, process status and so on when big data components are running\uff09We have also added statistics and display boards for common troubleshooting data such as Doris large query list, real-time write data volume, data import transaction numbers, etc. in Grafana.In Grafana, we also added statistics and display boards for common troubleshooting data such as the Doris big query list, the amount of real-time data written, and the number of data import transactions, so that alarms can be linked. When the cluster is abnormal, Doris\' operation and maintenance students can locate the cause of the cluster failure in the shortest time.\\n\\n## 02  Falcon \\n\\nFalcon is a monitoring and alarm system widely used inside Xiaomi.Because Doris provides a relatively complete metrics interface, which can easily provide monitoring functions based on Prometheus and Grafana, we only use Falcon\'s alarm function in the Doris service.For different levels of faults in Doris, we define alarms as three levels of P0, P1 and P2:\\n\\n- P2 alarm (alarm level is low): single node failure alarm.When a single node indicator or process status is abnormal, an alarm is generally issued as a P2 level.The alarm information is sent to the members of the alarm group in the form of Xiaomi Office messages.(Xiaomi Office is a privatized deployment product of ByteDance Feishu in Xiaomi, and its functions are similar to Feishu.)\\n\\n- P1 alarm (alarm level is higher):In a short period of time (within 3 minutes), the cluster will issue a P1 level alarm if there are short-term exceptions such as increased query delay and abnormal writing,etc.The alarm information is sent to the members of the alarm group in the form of Xiaomi Office messages.P1 level alarms require Oncall engineers to respond and provide feedback.\\n\\n- P0 alarm (alarm level is high):In a long period of time (more than 3 minutes), the cluster will issue a P0 level alarm if there are exceptions such as increased query delay and abnormal writing,etc.Alarm information is sent in the form of Xiaomi office messages and phone alarms.P0 level alarm requires Oncall engineers to respond within 1 minute and coordinate resources for failure recovery and review preparation.\\n\\n## 03  Cloud-Doris \\n\\ncloud-Doris is a data collection component developed by Xiaomi for the internal Doris service. Its main capability is to detect the availability of the Doris service and collect the cluster indicator data of internal concern.For example, Cloud-Doris can periodically simulate users reading and writing to the Doris system to detect the availability of services.If the cluster has abnormal availability, it will be alerted through Falcon.Collect user\'s read and write data, and then generate user bill.Collect information such as table-level data volume, unhealthy copies, and oversized Tablets, and send alarms to abnormal information through Falcon.\\n\\n## 04 QingZhou inspection\\n\\nFor chronic hidden dangers such as capacity, user growth, resource allocation, etc., we use the unified QingZhou big data service inspection platform for inspection and reporting.The inspection generally consists of two parts:Service-specific inspections and basic indicator inspections.Among them, the service-specific inspection refers to the indicators that are unique to each big data service and cannot be used universally.For Doris, it mainly includes: Quota, number of shard copies, number of single table columns, number of table partitions, etc.By increasing the inspection method, the chronic hidden dangers that are difficult to be alarmed in advance can be well avoided, which provides support for the failure-free major festivals.\\n\\n# Failure Recovery\\n\\nWhen an online cluster fails, the first principle should be to quickly restore services.If the cause of the failure is clear, handle it according to the specific cause and restore the service.If the cause of the failure is not clear, you should try restarting the process as soon as you keep the snapshot to restore the service.\\n\\n## 01 Access Failures Handling\\n\\nDoris uses Xiaomi LVS as the access layer, which is similar to the LB service of open source or public cloud, and provides layer 4 or layer 7 traffic load scheduling capability.After Doris binds a reasonable port,Generally speaking, if an abnormality occurs in a single FE node, it will be automatically kicked out, and the service can be restored without the user\'s perception, and an alarm will be issued for the abnormal node.Of course, for FE faults that cannot be processed in a short time, we will first adjust the weight of the faulty node to 0 or delete the abnormal node from LVS first to prevent unpredictable problems caused by process detection exceptions.\\n\\n## 02 Node Failure Handling\\n\\nFor FE node failures, if the cause of the failure cannot be quickly located, it is generally necessary to keep thread snapshots and memory snapshots and restart the process.\\n\\n```undefined\\njstack \u8fdb\u7a0bID >> \u5feb\u7167\u6587\u4ef6\u540d.jstack\\n```\\n\\nSave a memory snapshot of FE with the command:\\n\\n```undefined\\njmap -dump:live,format=b,file=\u5feb\u7167\u6587\u4ef6\u540d.heap \u8fdb\u7a0bID\\n```\\n\\nIn the case of version upgrade or some unexpected scenarios, the image of the FE node may have abnormal metadata, and the abnormal metadata may be synchronized to other FE, resulting in all FE not working.Once a failed image is discovered, the fastest recovery option is to use Recovery mode to stop FE elections and replace the failed image with the backup image.Of course, it is not easy to backup images all the time.Since this failure is common in cluster upgrades, we recommend adding simple local image backup logic to the cluster upgrade procedure.Ensure that a copy of the current and latest image data will be retained before each upgrade starts the FE process.For BE node failure, if the process crashes, a core file will be generated, and minos will automatically pull the process;If the task is stuck, you need to restart the process after retaining the thread snapshot with the following command:\\n\\n```undefined\\npstack \u8fdb\u7a0bID >> \u5feb\u7167\u6587\u4ef6\u540d.pstack\\n```\\n\\n# Concluding Remarks\\n\\nApache Doris has been widely used by Xiaomi since the first use of open source software Apache Doris by Xiaomi Group in September 2019.At present, it has served dozens of businesses of Xiaomi, with dozens of clusters and hundreds of nodes, and a set of data ecology with Apache Doris as the core has been formed within Xiaomi.In order to improve the efficiency of operation and maintenance, Xiaomi has also developed a complete set of automated management and operation and maintenance systems around Doris.With the increasing number of services, Doris also exposed some problems. For example, there was no better resource isolation mechanism in the past version, and services would affect each other. In addition, system monitoring needs to be further improved.With the rapid development of the community, more and more small partners have participated in the community construction, the vectorized engine has been transformed, the transformation of the query optimizer is in full swing, and Apache Doris is gradually maturing."},{"id":"/1.1 Release","metadata":{"permalink":"/blog/1.1 Release","source":"@site/blog/1.1 Release.md","title":"Apache Doris announced the official release of version 1.1","description":"Dear community, we are pleased to announce that we have officially released Apache Doris 1.1 on July 14, 2022! This is the first release version after Apache Doris graduated from the Apache incubator and became an Apache Top-Level Project.","date":"2022-07-14T00:00:00.000Z","formattedDate":"July 14, 2022","tags":[{"label":"Release Notes","permalink":"/blog/tags/release-notes"}],"truncated":false,"authors":[{"name":"Luzhijing"}],"frontMatter":{"title":"Apache Doris announced the official release of version 1.1","summary":"Dear community, we are pleased to announce that we have officially released Apache Doris 1.1 on July 14, 2022! This is the first release version after Apache Doris graduated from the Apache incubator and became an Apache Top-Level Project.","date":"2022-07-14","author":"Luzhijing","tags":["Release Notes"]},"prevItem":{"title":"Best Practice of Apache Doris in Xiaomi Group","permalink":"/blog/xiaomi"},"nextItem":{"title":"Announcing Open Source Realtime Analytical database Apache Doris as a Top-Level Project","permalink":"/blog/Annoucing"}},"content":"Dear community, we are pleased to announce that we have officially released Apache Doris 1.1 on July 14, 2022! This is the first release version after Apache Doris graduated from the Apache incubator and became an Apache Top-Level Project.\\n\\nIn version 1.1, we realized the full vectorization of the computing layer and storage layer, and officially enabled the vectorized execution engine as a stable function. All queries are executed by the vectorized execution engine by default, and the performance is 3-5 times higher than the previous version. It increases the ability to access the external tables of Apache Iceberg and supports federated query of data in Doris and Iceberg, and expands the analysis capabilities of Apache Doris on the data lake; on the basis of the original LZ4, the ZSTD compression algorithm is added , further improves the data compression rate; fixed many performance and stability problems in previous versions, greatly improving system stability. Downloading and using is recommended.\\n\\n## Upgrade Notes\\n\\n### The vectorized execution engine is enabled by default\\n\\nIn version 1.0, we introduced the vectorized execution engine as an experimental feature and Users need to manually enable it when executing queries by configuring the session variables through `set batch_size = 4096` and `set enable_vectorized_engine = true` .\\n\\nIn version 1.1, we officially fully enabled the vectorized execution engine as a stable function. The session variable `enable_vectorized_engine` is set to true by default. All queries are executed by default through the vectorized execution engine.\\n\\n### BE Binary File Renaming\\n\\nBE binary file has been renamed from palo_be to doris_be . Please pay attention to modifying the relevant scripts if you used to rely on process names for cluster management and other operations.\\n\\n### Segment storage format upgrade\\n\\nThe storage format of earlier versions of Apache Doris was Segment V1. In version 0.12, we had implemented Segment V2 as a new storage format, which introduced Bitmap indexes, memory tables, page cache, dictionary compression, delayed materialization and many other features. Starting from version 0.13, the default storage format for newly created tables is Segment V2, while maintaining compatibility with the Segment V1 format.\\n\\nIn order to ensure the maintainability of the code structure and reduce the additional learning and development costs caused by redundant historical codes, we have decided to no longer support the Segment v1 storage format from the next version. It is expected that this part of the code will be deleted in the Apache Doris 1.2 version, and all users who are still using the Segment V1 storage format must complete the data format conversion in version 1.1. Please refer to the following link for the operation manual:\\n\\n[https://doris.apache.org/zh-CN/docs/1.0/administrator-guide/segment-v2-usage](https://doris.apache.org/zh-CN/docs/1.0/administrator-guide/segment-v2-usage)\\n\\n### Normal Upgrade\\n\\nFor normal upgrade operations, you can perform rolling upgrades according to the cluster upgrade documentation on the official website.\\n\\n[https://doris.apache.org/zh-CN/docs/admin-manual/cluster-management/upgrade](https://doris.apache.org/zh-CN/docs/admin-manual/cluster-management/upgrade)\\n\\n## Features\\n\\n### Support random distribution of data [experimental]\\n\\nIn some scenarios (such as log data analysis), users may not be able to find a suitable bucket key to avoid data skew, so the system needs to provide additional distribution methods to solve the problem.\\n\\nTherefore, when creating a table you can set `DISTRIBUTED BY random BUCKET number`to use random distribution, the data will be randomly written to a single tablet when importing to reduce the data fanout during the loading process. And reduce resource overhead and improve system stability.\\n\\n### Support for creating Iceberg external tables[experimental]\\n\\nIceberg external tables provide Apache Doris with direct access to data stored in Iceberg. Through Iceberg external tables, federated queries on data stored in local storage and Iceberg can be implemented, which saves tedious data loading work, simplifies the system architecture for data analysis, and performs more complex analysis operations.\\n\\nIn version 1.1, Apache Doris supports creating Iceberg external tables and querying data, and supports automatic synchronization of all table schemas in the Iceberg database through the REFRESH command.\\n\\n### Added ZSTD compression algorithm\\n\\nAt present, the data compression method in Apache Doris is uniformly specified by the system, and the default is LZ4. For some scenarios that are sensitive to data storage costs, the original data compression ratio requirements cannot be met.\\n\\nIn version 1.1, users can set \\"compression\\"=\\"zstd\\" in the table properties to specify the compression method as ZSTD when creating a table. In the 25GB 110 million lines of text log test data, the highest compression rate is nearly 10 times, which is 53% higher than the original compression rate, and the speed of reading data from disk and decompressing it is increased by 30%.\\n\\n## Improvements\\n\\n### More comprehensive vectorization support\\n\\nIn version 1.1, we implemented full vectorization of the compute and storage layers, including:\\n\\nImplemented vectorization of all built-in functions\\n\\nThe storage layer implements vectorization and supports dictionary optimization for low-cardinality string columns\\n\\nOptimized and resolved numerous performance and stability issues with the vectorization engine.\\n\\nWe tested the performance of Apache Doris version 1.1 and version 0.15 on the SSB and TPC-H standard test datasets:\\n\\nOn all 13 SQLs in the SSB test data set, version 1.1 is better than version 0.15, and the overall performance is improved by about 3 times, which solves the problem of performance degradation in some scenarios in version 1.0;\\n\\nOn all 22 SQLs in the TPC-H test data set, version 1.1 is better than version 0.15, the overall performance is improved by about 4.5 times, and the performance of some scenarios is improved by more than ten times;\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edb59781b0f74ff08821467f23a63bad~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n<p align=\'center\'>SSB \u6d4b\u8bd5\u6570\u636e\u96c6</p>\\n\\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e34377054f4448b3b367789a391f2122~tplv-k3u1fbpfcp-zoom-1.image)\\n\\n<p align=\'center\'>TPC-H \u6d4b\u8bd5\u6570\u636e\u96c6</p>\\n\\n**Performance test report**\\n\\n[https://doris.apache.org/zh-CN/docs/benchmark/ssb](https://doris.apache.org/zh-CN/docs/benchmark/ssb)\\n\\n[https://doris.apache.org/zh-CN/docs/benchmark/tpch](https://doris.apache.org/zh-CN/docs/benchmark/tpch)\\n\\n### Compaction logic optimization and real-time guarantee\\n\\nIn Apache Doris, each commit will generate a data version. In high concurrent write scenarios, -235 errors are prone to occur due to too many data versions and untimely compaction, and query performance will also decrease accordingly.\\n\\nIn version 1.1, we introduced QuickCompaction, which will actively trigger compaction when the data version increases. At the same time, by improving the ability to scan fragment metadata, it can quickly find fragments with too many data versions and trigger compaction. Through active triggering and passive scanning, the real-time problem of data merging is completely solved.\\n\\nAt the same time, for high-frequency small file cumulative compaction, the scheduling and isolation of compaction tasks is implemented to prevent the heavyweight base compaction from affecting the merging of new data.\\n\\nFinally, for the merging of small files, the strategy of merging small files is optimized, and the method of gradient merging is adopted. Each time the files participating in the merging belong to the same data magnitude, it prevents versions with large differences in size from merging, and gradually merges hierarchically. , reducing the number of times a single file participates in merging, which can greatly save the CPU consumption of the system.\\n\\nWhen the data upstream maintains a write frequency of 10w per second (20 concurrent write tasks, 5000 rows per job, and checkpoint interval of 1s), version 1.1 behaves as follows:\\n\\n-   Quick data consolidation: Tablet version remains below 50 and compaction score is stable. Compared with the -235 problem that frequently occurred during high concurrent writing in the previous version, the compaction merge efficiency has been improved by more than 10 times.\\n\\n-   Significantly reduced CPU resource consumption: The strategy has been optimized for small file Compaction. In the above scenario of high concurrent writing, CPU resource consumption is reduced by 25%;\\n\\n-   Stable query time consumption: The overall orderliness of data is improved, and the fluctuation of query time consumption is greatly reduced. The query time consumption during high concurrent writing is the same as that of only querying, and the query performance is improved by 3-4 times compared with the previous version.\\n\\n### Read efficiency optimization for Parquet and ORC files\\n\\nBy adjusting arrow parameters, arrow\'s multi-threaded read capability is used to speed up Arrow\'s reading of each row_group, and it is modified to SPSC model to reduce the cost of waiting for the network through prefetching. After optimization, the performance of Parquet file import is improved by 4 to 5 times.\\n\\n### Safer metadata Checkpoint\\n\\nBy double-checking the image files generated after the metadata checkpoint and retaining the function of historical image files, the problem of metadata corruption caused by image file errors is solved.\\n\\n## Bugfix\\n\\n### Fix the problem that the data cannot be queried due to the missing data version.(Serious)\\n\\nThis issue was introduced in version 1.0 and may result in the loss of data versions for multiple replicas.\\n\\n### Fix the problem that the resource isolation is invalid for the resource usage limit of loading tasks (Moderate)\\n\\nIn 1.1, the broker load and routine load will use Backends with specified resource tags to do the load.\\n\\n### Use HTTP BRPC to transfer network data packets over 2GB (Moderate)\\n\\nIn the previous version, when the data transmitted between Backends through BRPC exceeded 2GB,\\nit may cause data transmission errors.\\n\\n## Others\\n\\n### Disabling Mini Load\\n\\nThe `/_load` interface is disabled by default, please use `the /_stream_load` interface uniformly.\\nOf course, you can re-enable it by turning off the FE configuration item `disable_mini_load`.\\n\\nThe Mini Load interface will be completely removed in version 1.2.\\n\\n### Completely disable the SegmentV1 storage format\\n\\nData in SegmentV1 format is no longer allowed to be created. Existing data can continue to be accessed normally.\\nYou can use the `ADMIN SHOW TABLET STORAGE FORMAT` statement to check whether the data in SegmentV1 format\\nstill exists in the cluster. And convert to SegmentV2 through the data conversion command\\n\\nAccess to SegmentV1 data will no longer be supported in version 1.2.\\n\\n### Limit the maximum length of String type\\n\\nIn previous versions, String types were allowed a maximum length of 2GB.\\nIn version 1.1, we will limit the maximum length of the string type to 1MB. Strings longer than this length cannot be written anymore.\\nAt the same time, using the String type as a partitioning or bucketing column of a table is no longer supported.\\n\\nThe String type that has been written can be accessed normally.\\n\\n### Fix fastjson related vulnerabilities\\n\\nUpdate to Canal version to fix fastjson security vulnerability.\\n\\n### Added `ADMIN DIAGNOSE TABLET` command\\n\\nUsed to quickly diagnose problems with the specified tablet.\\n\\n## Download to Use\\n\\n### Download Link\\n\\n[hhttps://doris.apache.org/download](https://doris.apache.org/download)\\n\\n### Feedback\\n\\nIf you encounter any problems with use, please feel free to contact us through GitHub discussion forum or Dev e-mail group anytime.\\n\\nGitHub Forum: [https://github.com/apache/doris/discussions](https://github.com/apache/doris/discussions)\\n\\nMailing list: [dev@doris.apache.org](dev@doris.apache.org)\\n\\n## Thanks\\n\\nThanks to everyone who has contributed to this release:\\n\\n```\\n\\n@adonis0147\\n\\n@airborne12\\n\\n@amosbird\\n\\n@aopangzi\\n\\n@arthuryangcs\\n\\n@awakeljw\\n\\n@BePPPower\\n\\n@BiteTheDDDDt\\n\\n@bridgeDream\\n\\n@caiconghui\\n\\n@cambyzju\\n\\n@ccoffline\\n\\n@chenlinzhong\\n\\n@daikon12\\n\\n@DarvenDuan\\n\\n@dataalive\\n\\n@dataroaring\\n\\n@deardeng\\n\\n@Doris-Extras\\n\\n@emerkfu\\n\\n@EmmyMiao87\\n\\n@englefly\\n\\n@Gabriel39\\n\\n@GoGoWen\\n\\n@gtchaos\\n\\n@HappenLee\\n\\n@hello-stephen\\n\\n@Henry2SS\\n\\n@hewei-nju\\n\\n@hf200012\\n\\n@jacktengg\\n\\n@jackwener\\n\\n@Jibing-Li\\n\\n@JNSimba\\n\\n@kangshisen\\n\\n@Kikyou1997\\n\\n@kylinmac\\n\\n@Lchangliang\\n\\n@leo65535\\n\\n@liaoxin01\\n\\n@liutang123\\n\\n@lovingfeel\\n\\n@luozenglin\\n\\n@luwei16\\n\\n@luzhijing\\n\\n@mklzl\\n\\n@morningman\\n\\n@morrySnow\\n\\n@nextdreamblue\\n\\n@Nivane\\n\\n@pengxiangyu\\n\\n@qidaye\\n\\n@qzsee\\n\\n@SaintBacchus\\n\\n@SleepyBear96\\n\\n@smallhibiscus\\n\\n@spaces-X\\n\\n@stalary\\n\\n@starocean999\\n\\n@steadyBoy\\n\\n@SWJTU-ZhangLei\\n\\n@Tanya-W\\n\\n@tarepanda1024\\n\\n@tianhui5\\n\\n@Userwhite\\n\\n@wangbo\\n\\n@wangyf0555\\n\\n@weizuo93\\n\\n@whutpencil\\n\\n@wsjz\\n\\n@wunan1210\\n\\n@xiaokang\\n\\n@xinyiZzz\\n\\n@xlwh\\n\\n@xy720\\n\\n@yangzhg\\n\\n@Yankee24\\n\\n@yiguolei\\n\\n@yinzhijian\\n\\n@yixiutt\\n\\n@zbtzbtzbt\\n\\n@zenoyang\\n\\n@zhangstar333\\n\\n@zhangyifan27\\n\\n@zhannngchen\\n\\n@zhengshengjun\\n\\n@zhengshiJ\\n\\n@zingdle\\n\\n@zuochunwei\\n\\n@zy-kkk\\n```"},{"id":"/Annoucing","metadata":{"permalink":"/blog/Annoucing","source":"@site/blog/Annoucing.md","title":"Announcing Open Source Realtime Analytical database Apache Doris as a Top-Level Project","description":"Apache Doris is a modern, high-performance and real-time analytical database based on MPP. It is well known for its high-performance and easy-to-use. It can return query results under massive data within only sub-seconds. It can support not only high concurrent point query scenarios, but also complex analysis scenarios with high throughput. Based on this, Apache Doris can be well applied in many business fields, such as multi-dimensional reporting, user portrait, ad-hoc query, real-time dashboard and so on.","date":"2022-06-16T00:00:00.000Z","formattedDate":"June 16, 2022","tags":[{"label":"Top News","permalink":"/blog/tags/top-news"}],"truncated":false,"authors":[{"name":"morningman"}],"frontMatter":{"title":"Announcing Open Source Realtime Analytical database Apache Doris as a Top-Level Project","summary":"Apache Doris is a modern, high-performance and real-time analytical database based on MPP. It is well known for its high-performance and easy-to-use. It can return query results under massive data within only sub-seconds. It can support not only high concurrent point query scenarios, but also complex analysis scenarios with high throughput. Based on this, Apache Doris can be well applied in many business fields, such as multi-dimensional reporting, user portrait, ad-hoc query, real-time dashboard and so on.","date":"2022-06-16","author":"morningman","tags":["Top News"]},"prevItem":{"title":"Apache Doris announced the official release of version 1.1","permalink":"/blog/1.1 Release"},"nextItem":{"title":"[Release Note] Apache Doris(Incubating) 1.0.0 Release","permalink":"/blog/release-note-1.0.0"}},"content":"Apache Doris is a modern, high-performance and real-time analytical database based on MPP. It is well known for its high-performance and easy-to-use. It can return query results under massive data within only sub-seconds. It can support not only high concurrent point query scenarios, but also complex analysis scenarios with high throughput. Based on this, Apache Doris can be well applied in many business fields, such as multi-dimensional reporting, user portrait, ad-hoc query, real-time dashboard and so on.\\n\\nApache Doris was first born in the Palo Project within Baidu\'s advertising report business and officially opened source in 2017. It was donated by Baidu to Apache foundation for incubation in July 2018, and then incubated and operated by members of the podling project management committee\uff08PPMC\uff09under the guidance of Apache incubator mentors.\\n\\nWe are very proud that Doris graduated from Apache incubator successfully. It is an important milestone. In the whole incubating period, with the guidance of Apache Way and the help of incubator mentors, we learned how to develop our project and community in Apache Way, and have achieved great growth in this process.\\n\\nAt present, Apache Doris community has gathered more than 300 contributors from nearly 100 enterprises in different industries, and the number of active contributors per month is close to 100. During the incubation period, Apache Doris released a total of 8 major versions and completed many major functions, including storage engine upgrade, vectorization execution engine and so on, and released 1.0 version. It is the strength of these open source contributors that makes Apache Doris achieve today\'s results.\\n\\nAt the same time, Apache Doris now has a wide range of users in China and even around the world. Up to now, Apache Doris has been applied in the production environment of more than 500 enterprises around the world. Among the top 50 Internet companies in China by market value or valuation, more than 80% are long-term users of Apache Doris, including Baidu, Meituan, Xiaomi, JD, ByteDance, Tencent, Kwai, Netease, Sina, 360 and other well-known companies. It also has rich applications in some traditional industries, such as finance, energy, manufacturing, telecommunications and other fields.\\n\\nYou can quickly build a simple, easy-to-use and powerful data analysis platform based on Apache Doris, which is very easy to start, and the learning cost is very low. In addition, the distributed architecture of Apache Doris is very simple, which can greatly reduce the workload of system operation and maintenance. This is also the key factor for more and more users to choose Apache Doris.\\n\\nAs a mature analytical database project, Apache Doris has the following advantages:\\n\\n-   Excellent performance: it is equipped with an efficient column storage engine, which not only reduces the amount of data scanning, but also implements an ultra-high data compression ratio. At the same time, Doris also provides a rich index structure to speed up data reading and filtering. Using the partition and bucket pruning function, Doris can support ultra-high concurrency of online service business, and a single node can support up to thousands of QPS. Further, Apache Doris combines the vectorization execution engine to give full play to the modern CPU parallel computing power, supplemented by intelligent materialized view technology to accelerate pre-aggregation, and can simultaneously carry out planning based and cost based query optimization through the query optimizer. Through the above methods, Doris can reach ultimate query performance.\\n\\n-   Easy to use: it supports ANSI SQL syntax, including single table aggregation, sorting, filtering and multi table join, sub query, etc. it also supports complex SQL syntax such as window function and grouping set. At the same time, users can expand system functions through UDF, UDAF and other user-defined functions. In addition, Apache Doris is also compatible with MySQL protocol. Users can access Doris through various client tools and support seamless connection with BI tools.\\n\\n-   Streamlined architecture: the system has only two modules \u2014\u2014 frontend (FE) and backend (BE). The FE node is responsible for the access of user requests, the analysis of query plans, metadata storage and cluster management, and the BE node is responsible for the implementation of data storage and query plans. It is a complete distributed database management system. Users can run the Apache Doris cluster without installing any third-party management and control components, and the deployment and upgrade process are very simple. At the same time, any module can support horizontal expansion, and the cluster can be expanded up to hundreds of nodes, supporting the storage of more than 10PB of ultra large scale data.\\n\\n-   Scalability and reliability: it supports the storage of multiple replicas of data. The cluster is able to self-healing. Its own distributed management framework can automatically manage the distribution, repair and balance of data replicas. When the replicas are damaged, the system can automatically perceive and repair them. When a node is expanded, it can be completed with only one SQL command, and the data replicas will be automatically rebalanced among nodes without manual intervention or operation. Whether it is capacity expansion, capacity reduction, single node failure or upgrading, the system does not need to stop running, and can normally provide stable and reliable online services.\\n\\n-   Ecological enrichment: It provides rich data synchronisation methods, supports fast loading of data from localhost, Hadoop, Flink, Spark, Kafka, SeaTunnel and other systems, and can also directly access data in MySQL, PostgreSQL, Oracle, S3, Hive, Iceberg, Elasticsearch and other systems without data replication. At the same time, the data stored in Doris can also be read by Spark and Flink, and can be output to the upstream data application for display and analysis.\\n\\nGraduation is not the ultimate goal, it is the starting point of a new journey. In the past, our goal of launching Doris was to provide more people with better data analysis tools and solve their data analysis problems. Becoming an Apache top-level project is not only an affirmation of the hard work of all contributors to the Apache Doris community in the past, but also means that we have established a strong, prosperous and sustainable open source community under the guidance of Apache Way.In the future, we will continue to operate the community in the Way of Apache. I believe we will attract more excellent open source contributors to participate in the community, and the community will further grow with the help of all contributors.\\n\\nApache Doris will carry out more challenging and meaningful work in the future, including new query optimizer, support for Lakehouse integration, and architecture evolution for cloud infrastructure. More open source technology enthusiasts are welcome to join the Apache Doris community and grow together.\\n\\nOnce again, we sincerely thank all contributors who participated in the construction of Apache Doris community and all users who use Apache Doris and constantly put forward improvement suggestions. At the same time, we also thank our incubator mentors, IPMC members and friends in various open source project communities who have continuously encouraged, supported and helped us all the way.\\n\\n**Apache Doris GitHub\uff1a**\\n\\n[https://github.com/apache/doris](https://github.com/apache/doris)\\n\\n**Apache Doris website:**\\n\\n[http://doris.apache.org](http://doris.apache.org)\\n\\n**Please contact us via:**\\n\\n[dev@doris.apache.org.](dev@doris.apache.org.)\\n\\n**See How to subscribe:**\\n\\n[https://doris.apache.org/zh-CN/community/subscribe-mail-list](https://doris.apache.org/zh-CN/community/subscribe-mail-list)"},{"id":"/release-note-1.0.0","metadata":{"permalink":"/blog/release-note-1.0.0","source":"@site/blog/release-note-1.0.0.md","title":"[Release Note] Apache Doris(Incubating) 1.0.0 Release","description":"\x3c!--","date":"2022-04-18T00:00:00.000Z","formattedDate":"April 18, 2022","tags":[{"label":"Release Notes","permalink":"/blog/tags/release-notes"}],"truncated":false,"authors":[{"name":"Luzhijing"}],"frontMatter":{"title":"[Release Note] Apache Doris(Incubating) 1.0.0 Release","summary":"[Release Note] Apache Doris(Incubating) 1.0.0 Release","date":"2022-04-18","author":"Luzhijing","tags":["Release Notes"]},"prevItem":{"title":"Announcing Open Source Realtime Analytical database Apache Doris as a Top-Level Project","permalink":"/blog/Annoucing"},"nextItem":{"title":"[Release Note] Apache Doris(Incubating) 0.15.0 Release","permalink":"/blog/release-note-0.15.0"}},"content":"\x3c!--\\nLicensed to the Apache Software Foundation (ASF) under one\\nor more contributor license agreements.  See the NOTICE file\\ndistributed with this work for additional information\\nregarding copyright ownership.  The ASF licenses this file\\nto you under the Apache License, Version 2.0 (the\\n\\"License\\"); you may not use this file except in compliance\\nwith the License.  You may obtain a copy of the License at\\n\\n  http://www.apache.org/licenses/LICENSE-2.0\\n\\nUnless required by applicable law or agreed to in writing,\\nsoftware distributed under the License is distributed on an\\n\\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\nKIND, either express or implied.  See the License for the\\nspecific language governing permissions and limitations\\nunder the License.\\n--\x3e\\n\\n# Apache Doris(Incubating) 1.0.0 Release\\n\\nDear community friends, after several months, we are happy to announce that Apache Doris (incubating) has officially released the 1.0 Release version on April 18, 2022! **This is the first 1-bit version of Apache Doris since it was incubated by the Apache Foundation, and it is also the version with the largest refactoring of the core code of Apache Doris so far****! **With **114 Contributors** committing **over 660 optimizations and fixes** for Apache Doris, thank you to everyone who makes Apache Doris even better!\\n\\nIn version 1.0, we introduced important functions such as vectorized execution engine, Hive external table, Lateral View syntax and Table Function table function, Z-Order data index, Apache SeaTunnel plug-in, etc., and added support for synchronous update and deletion of data in Flink CDC. Support, optimize many problems in the process of data import and query, and comprehensively enhance the query performance, ease of use, stability and other special effects of Apache Doris. Welcome to download and use! Click \\"**Read the original text**\\" at the end of the article to go directly to the download address.\\n\\nEvery day that has not been published, there are countless contributors behind it, who dare not stop for half a minute. Here we would like to especially thank the small partners from SIG (Special Interest Group) such as **vectorized execution engine, query optimizer, and visual operation and maintenance platform**. Since the establishment of the Apache Doris Community SIG group in August 2021, data from more than ten companies including Baidu, Meituan, Xiaomi, JD, Shuhai, ByteDance, Tencent, NetEase, Alibaba, PingCAP, Nebula Graph, etc. Ten contributors** joined the SIG as the first members, and for the first time completed the development of such major functions as the vectorized execution engine, query optimizer, and Doris Manager visual monitoring operation and maintenance platform in the form of open source collaboration of special groups. **During more than half a year, conducting technical research and sharing dozens of times, holding nearly 100 remote meetings, accumulatively submitting hundreds of Commits, involving more than 100,000 lines of code**, it is precisely because of their contributions , only the 1.0 version came out, let us once again express our most sincere thanks for their hard work!\\n\\nAt the same time, the number of Apache Doris contributors has exceeded 300, the number of monthly active contributors has exceeded 60, and the average weekly number of Commits submitted in recent weeks has also exceeded 80. The scale and activity of developers gathered by the community There has been a huge improvement. We are very much looking forward to having more small partners participate in the community contribution, and work with us to build Apache Doris into the world\'s top analytical database. We also hope that all small partners can reap valuable growth with us. If you would like to participate in the community, please contact us via the developer email dev@doris.apache.org.\\n\\nWe welcome you to contact us with any questions during the use process through GitHub Discussion or Dev mail group, and we look forward to your participation in community discussions and construction.\\n\\n\\n## Important update \\n\\n### Vectorized Execution Engine [Experimental]\\n\\nIn the past, the SQL execution engine of Apache Doris was designed based on the row-based memory format and the traditional volcano model. There was unnecessary overhead in performing SQL operator and function operations, which led to the limited efficiency of the Apache Doris execution engine, which did not Adapt to the architecture of modern CPUs. The goal of the vectorized execution engine is to replace the current row-based SQL execution engine of Apache Doris, fully release the computing power of modern CPUs, break through the performance limitations on the SQL execution engine, and exert extreme performance.\\n\\nBased on the characteristics of modern CPUs and the execution characteristics of the volcano model, the vectorized execution engine redesigned the SQL execution engine in the columnar storage system:\\n\\n- Reorganized the data structure of memory, replaced Tuple with Column, improved Cache affinity, branch prediction and prefetch memory friendliness during calculation\\n- Type judgment is performed in batches. In this batch, the type determined during type judgment is used, and the virtual function cost of type judgment of each line is allocated to the batch level.\\n- Through batch-level type judgment, virtual function calls are eliminated, allowing the compiler to have the opportunity for function inlining and SIMD optimization\\n\\nThis greatly improves the efficiency of the CPU when executing SQL and improves the performance of SQL queries.\\n\\nIn Apache Doris version 1.0, enabling the vectorized execution engine with set batch_size = 4096 and set enable_vectorized_engine = true can significantly improve query performance in most cases. Under the SSB and OnTime standard test datasets, the overall performance of the two scenarios of multi-table association and wide-column query is improved by 3 times and 2.6 times respectively.\\n\\n![](/images/blogs/1.0/1.0.0-1.png)\\n\\n![](/images/blogs/1.0/1.0.0-2.png)\\n\\n### Lateral View Grammar [Experimental]\\n\\nThrough Lateral View syntax, we can use Table Function table functions such as explode_bitmap, explode_split, explode_jaon_array, etc., to expand bitmap, String or Json Array from one column into multiple rows, so that the expanded data can be further processed (such as Filter, Join, etc.) .\\n\\n### Hive External Table [Experimental]\\n\\nHive External Table provides users with the ability to directly access Hive tables through Doris. External tables save the tedious data import work, and can use Doris\'s own OLAP capabilities to solve data analysis problems of Hive tables. The current version supports connecting Hive data sources to Doris, and supports federated queries through data in Doris and Hive data sources for more complex analysis operations.\\n\\n### Support Z-Order data sorting format\\n\\nApache Doris data is sorted and stored according to the prefix column, so when the prefix query condition is included, fast data search can be performed on the sorted data, but if the query condition is not a prefix column, the data sorting feature cannot be used for fast data search. The above problems can be solved by Z-Order Indexing. In version 1.0, we have added the Z-Order data sorting format, which can play a good filtering effect in the scenario of kanban multi-column query and accelerate the filtering performance of non-prefix column conditions. .\\n\\n### Support for Apache SeaTunnel (Incubating) plugin\\n\\nApache SeaTunnel is a high-performance distributed data integration framework built on Apache Spark and Apache Flink. In the 1.0 version of Apache Doris, we have added the SaeTunnel plugin, users can use Apache SeaTunnel for synchronization and ETL between multiple data sources.\\n\\n### New Function\\n\\nMore bitmap functions are supported, see the function manual for details:\\n\\n- bitmap_max\\n- bitmap_and_not\\n- bitmap_and_not_count\\n- bitmap_has_all\\n- bitmap_and_count\\n- bitmap_or_count\\n- bitmap_xor_count\\n- bitmap_subset_limit\\n- sub_bitmap\\n\\nSupport national secret algorithm SM3/SM4;\\n\\n\\n\\n> **Note**: The functions marked [Experimental] above are experimental functions. We will continue to optimize and iterate on the above functions in subsequent versions, and further improve them in subsequent versions. If you have any questions or comments during use, please feel free to contact us\\n\\n### Important Optimization\\n\\n### Features Optimization\\n\\n* Reduced the number of segment files generated when importing in large batches to reduce Compaction pressure.\\n* Transfer data through BRPC\'s attachment function to reduce serialization and deserialization overhead during query.\\n* Support to directly return binary data of HLL/BITMAP type for external analysis of business.\\n* Optimize and reduce the probability of OVERCROWDED and NOT_CONNECTED errors in BRPC, and enhance system stability.\\n* Enhance the fault tolerance of import.\\n* Support to update and delete data synchronously through Flink CDC.\\n* Support adaptive Runtime Filter.\\n* Significantly reduce the memory footprint of insert into operations\\n\\n\\n### Usability Improvements\\n\\n* Routine Load supports displaying the current offset delay number and other status.\\n* Added statistics on peak memory usage of queries in FE audit log.\\n* Added missing version information to Compaction URL results to facilitate troubleshooting.\\n* Support marking BE as non-queryable or non-importable to quickly screen problem nodes.\\n\\n### Important Bug Fixes\\n\\n* Fixed several query errors.\\n* Fixed some scheduling logic issues in Broker Load.\\n* Fix the problem that the metadata cannot be loaded due to the STREAM keyword.\\n* Fixed Decommission not executing correctly.\\n* Fix the problem that -102 error may occur when operating Schema Change operation in some cases.\\n* Fix the problem that using String type may cause BE to crash in some cases.\\n\\n### Other\\n\\n* Added Minidump function; easy to locate when problems occur\\n\\n## Changelog\\n\\nFor detailed Release Note, please check the link:\\n\\nhttps://github.com/apache/incubator-doris/issues/8549\\n\\n## Thanks  \\n\\nThe release of Apache Doris(incubating) 1.0 Release version is inseparable from the support of all community users. I would like to express my gratitude to all community contributors who participated in version design, development, testing and discussion. They are:\\n\\n```\\n@924060929\\n@adonis0147\\n@Aiden-Dong\\n@aihai\\n@airborne12\\n@Alibaba-HZY\\n@amosbird\\n@arthuryangcs\\n@awakeljw\\n@bingzxy\\n@BiteTheDDDDt\\n@blackstar-baba\\n@caiconghui\\n@CalvinKirs\\n@cambyzju\\n@caoliang-web\\n@ccoffline\\n@chaplinthink\\n@chovy-3012\\n@ChPi\\n@DarvenDuan\\n@dataalive\\n@dataroaring\\n@dh-cloud\\n@dohongdayi\\n@dongweizhao\\n@drgnchan\\n@e0c9\\n@EmmyMiao87\\n@englefly\\n@eyesmoons\\n@freemandealer\\n@Gabriel39\\n@gaodayue\\n@GoGoWen\\n@Gongruixiao\\n@gwdgithubnom\\n@HappenLee\\n@Henry2SS\\n@hf200012\\n@htyoung\\n@jacktengg\\n@jackwener\\n@JNSimba\\n@Keysluomo\\n@kezhenxu94\\n@killxdcj\\n@lihuigang\\n@littleeleventhwolf\\n@liutang123\\n@liuzhuang2017\\n@lonre\\n@lovingfeel\\n@luozenglin\\n@luzhijing\\n@MeiontheTop\\n@mh-boy\\n@morningman\\n@mrhhsg\\n@Myasuka\\n@nimuyuhan\\n@obobj\\n@pengxiangyu\\n@qidaye\\n@qzsee\\n@renzhimin7\\n@Royce33\\n@SleepyBear96\\n@smallhibiscus\\n@sodamnsure\\n@spaces-X\\n@sparklezzz\\n@stalary\\n@steadyBoy\\n@tarepanda1024\\n@THUMarkLau\\n@tianhui5\\n@tinkerrrr\\n@ucasfl\\n@Userwhite\\n@vinson0526\\n@wangbo\\n@wangshuo128\\n@wangyf0555\\n@weajun\\n@weizuo93\\n@whutpencil\\n@WindyGao\\n@wunan1210\\n@xiaokang\\n@xiaokangguo\\n@xiedeyantu\\n@xinghuayu007\\n@xingtanzjr\\n@xinyiZzz\\n@xtr1993\\n@xu20160924\\n@xuliuzhe\\n@xuzifu666\\n@xy720\\n@yangzhg\\n@yiguolei\\n@yinzhijian\\n@yjant\\n@zbtzbtzbt\\n@zenoyang\\n@zh0122\\n@zhangstar333\\n@zhannngchen\\n@zhengshengjun\\n@zhengshiJ\\n@ZhikaiZuo\\n@ztgoto\\n@zuochunwei\\n```"},{"id":"/release-note-0.15.0","metadata":{"permalink":"/blog/release-note-0.15.0","source":"@site/blog/release-note-0.15.0.md","title":"[Release Note] Apache Doris(Incubating) 0.15.0 Release","description":"\x3c!--","date":"2021-11-29T00:00:00.000Z","formattedDate":"November 29, 2021","tags":[{"label":"Release Notes","permalink":"/blog/tags/release-notes"}],"truncated":false,"authors":[{"name":"Luzhijing"}],"frontMatter":{"title":"[Release Note] Apache Doris(Incubating) 0.15.0 Release","summary":"[Release Note] Apache Doris(Incubating) 0.15.0 Release","date":"2021-11-29","author":"Luzhijing","tags":["Release Notes"]},"prevItem":{"title":"[Release Note] Apache Doris(Incubating) 1.0.0 Release","permalink":"/blog/release-note-1.0.0"}},"content":"\x3c!--\\nLicensed to the Apache Software Foundation (ASF) under one\\nor more contributor license agreements.  See the NOTICE file\\ndistributed with this work for additional information\\nregarding copyright ownership.  The ASF licenses this file\\nto you under the Apache License, Version 2.0 (the\\n\\"License\\"); you may not use this file except in compliance\\nwith the License.  You may obtain a copy of the License at\\n\\n  http://www.apache.org/licenses/LICENSE-2.0\\n\\nUnless required by applicable law or agreed to in writing,\\nsoftware distributed under the License is distributed on an\\n\\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\nKIND, either express or implied.  See the License for the\\nspecific language governing permissions and limitations\\nunder the License.\\n--\x3e\\n\\n# Apache Doris(Incubating) 0.15.0 Release\\n\\nDear Community, After months of polishing, we are pleased to announce the release of Apache Doris(Incubating) on November 29, 2021! Nearly 700 optimizations and fixes have been submitted by 99 contributors to Apache Doris, and we\'d like to express our sincere gratitude to all of them!\\n\\nIn the 0.15.0 Release, we have added many new features to optimize Apache Doris\'s query performance, ease of use, and stability: a new resource division and isolation feature that allows users to divide BE nodes in a cluster into resource groups by means of resource tags, enabling unified management of online and offline services and resource isolation; the addition of Runtime Filter and Join Reorder functions have been added to significantly improve the query efficiency of multi-table Join scenarios, with a 2-10 times performance improvement under the Star Schema Benchmark test data set; new import method Binlog Load enables Doris to incrementally synchronize the CDC of data update operations in MySQL; support for String column type The new import method, Binlog Load, allows Doris to incrementally synchronize the CDC of MySQL for data update operations; supports String column type with a maximum length of 2GB; supports List partitioning to create partitions by enumerating values; supports Update statements on the Unique Key model; Spark-Doris-Connector supports data writing to Doris ... ...and many more important features, welcome to download and use.\\n\\nWe welcome you to contact us via GitHub Discussion or the Dev email group if you have any questions during use, and we look forward to your participation in community discussions and building.\\n\\n## High Lights\\n\\n### Resource Segregation and Isolation\\n\\nYou can divide BE nodes in a Doris cluster into resource groups by using resource tags, allowing you to manage online and offline operations and isolate resources at the node level.\\nYou can also control the resource overhead of individual queries by limiting the CPU and memory overhead and complexity of individual query tasks, thus reducing the resource hogging problem between different queries.\\n\\n### Performance Optimization\\n\\n* The Runtime Filter feature can significantly improve query efficiency in most Join scenarios by using the Join Key column condition of the right table in the Join algorithm to filter the data in the left table. For example, you can get 2-10 times performance improvement under Star Schema Benchmark (TPCH\'s streamlined test set).\\n\\n* The Join Reorder feature can automatically help adjust the order of joins in SQL by using a cost model to help achieve optimal join efficiency.\\nIt can be enabled via the session variable `set enable_cost_based_join_reorder=true`.\\n\\n### New features\\n\\n* Support synchronizing MySQL binlog data directly to Canal Server.\\n* Support String column type, support up to 2GB.\\n* Support List partitioning, you can create partitions for enumerated values.\\n* Support transactional Insert statement function. You can import data in bulk by begin ; insert ; insert;, ... You can import data in bulk by begin ; insert ; insert ;, ... ;.\\n* Support Update statement function on Unique Key model. You can execute Update Set where statement on Unique Key model table.\\n* Support SQL blocking list function. You can block some SQL execution by regular, hash value matching, etc.\\n* Support LDAP login authentication.\\n\\n### Extended Features\\n\\n* Support Flink-Doris-Connector.\\n* Support for DataX doriswriter plugin.\\n* Spark-Doris-Connector support for data writing to Doris.\\n \\n## Feature Optimization \\n\\n### Query\\n\\n* Support for computing all constant expressions in the SQL query planning phase using BE\'s functional computing power.\\n\\n### Import\\n\\n* Support for specifying multi-byte row separators or invisible separators when importing text format files.\\n* Supports importing compressed format files via Stream Load.\\n* Stream Load supports importing Json data in multi-line format.\\n\\n### Export\\n\\n* Support Export export function to specify where filter. Supports exporting files with multi-byte row separators. Support export to local files.\\n* Export export function supports exporting only specified columns.\\n* Supports exporting the result set to local disk via outfile statement and writing the exported marker file after exporting.\\n\\n### Ease of use\\n\\n* Dynamic partitioning function supports creating and keeping specified historical partitions, and supports automatic hot and cold data migration settings.\\n* Supports displaying queries, imported schedules and Profiles using a visual tree structure at the command line.\\n* Support to record and view Stream Load operation logs.\\n* When consuming Kafka data via Routine Load, you can specify the time point for consumption.\\n* Supports exporting Routine Load creation statements by show create routine load function.\\n* Support to start and stop all Routine Load jobs with one click by pause/resume all routine load command.\\n* Supports modifying the Broker List and Topic of Routine Load by alter routine load statement.\\n* Support create table as select function.\\n* Support modify column comments and table comments by alter table command.\\n* show tablet status to add table creation time and data update time.\\n* Support show data skew command to check the data volume distribution of a table to troubleshoot data skewing problems.\\n* Support show/clean trash command to check the disk occupation of BE file recycle bin and clear it actively.\\n* Support show view statement to show which views a table is referenced by.\\n\\n### New functions\\n\\n* `bitmap_min`, `bit_length`\\n* `yearweek`, `week`, `makedate`\\n* `percentile` exact percentile function\\n* `json_array`, `json_object`, `json_quote`\\n* Support for creating custom public keys for the `AES_ENCRYPT` and `AES_DECRYPT` functions.\\n* Support for creating function aliases to combine multiple functions by `create alias function`.\\n\\n### Other\\n\\n* Support for accessing the ES exterior of the SSL connection protocol.\\n* Support specifying the number of hotspot partitions in the dynamic partition property, which will be stored in SSD disks.\\n* Support importing Json format data via Broker Load.\\n* Supports accessing HDFS directly through libhdfs3 library for data import and export without the Broker process.\\n* select into outfile function supports exporting Parquet file format and parallel export.\\n* ODBC external table support for SQLServer. \\n\\n## \u81f4\u8c22  \\n\\nThe release of Apache Doris (incubating) 0.15.0 Release is made possible by the support of all community users. We would like to thank all the community contributors who participated in the design, development, testing, and discussion of the release, namely.\\n\\n* [@924060929](https://github.com/924060929)\\n* [@acelyc111](https://github.com/acelyc111)\\n* [@Aimiyoo](https://github.com/Aimiyoo)\\n* [@amosbird](https://github.com/amosbird)\\n* [@arthur-zhang](https://github.com/arthur-zhang)\\n* [@azurenake](https://github.com/azurenake)\\n* [@BiteTheDDDDt](https://github.com/BiteTheDDDDt)\\n* [@caiconghui](https://github.com/caiconghui)\\n* [@caneGuy](https://github.com/caneGuy)\\n* [@caoliang-web](https://github.com/caoliang-web)\\n* [@ccoffline](https://github.com/ccoffline)\\n* [@chaplinthink](https://github.com/chaplinthink)\\n* [@chovy-3012](https://github.com/chovy-3012)\\n* [@ChPi](https://github.com/ChPi)\\n* [@copperybean](https://github.com/copperybean)\\n* [@crazyleeyang](https://github.com/crazyleeyang)\\n* [@dh-cloud](https://github.com/dh-cloud)\\n* [@DinoZhang](https://github.com/DinoZhang)\\n* [@dixingxing0](https://github.com/dixingxing0)\\n* [@dohongdayi](https://github.com/dohongdayi)\\n* [@e0c9](https://github.com/e0c9)\\n* [@EmmyMiao87](https://github.com/EmmyMiao87)\\n* [@eyesmoons](https://github.com/eyesmoons)\\n* [@francisoliverlee](https://github.com/francisoliverlee)\\n* [@Gabriel39](https://github.com/Gabriel39)\\n* [@gaodayue](https://github.com/gaodayue)\\n* [@GoGoWen](https://github.com/GoGoWen)\\n* [@HappenLee](https://github.com/HappenLee)\\n* [@harveyyue](https://github.com/harveyyue)\\n* [@Henry2SS](https://github.com/Henry2SS)\\n* [@hf200012](https://github.com/hf200012)\\n* [@huangmengbin](https://github.com/huangmengbin)\\n* [@huozhanfeng](https://github.com/huozhanfeng)\\n* [@huzk8](https://github.com/huzk8)\\n* [@hxianshun](https://github.com/hxianshun)\\n* [@ikaruga4600](https://github.com/ikaruga4600)\\n* [@JameyWoo](https://github.com/JameyWoo)\\n* [@Jennifer88huang](https://github.com/Jennifer88huang)\\n* [@JinLiOnline](https://github.com/JinLiOnline)\\n* [@jinyuanlu](https://github.com/jinyuanlu)\\n* [@JNSimba](https://github.com/JNSimba)\\n* [@killxdcj](https://github.com/killxdcj)\\n* [@kuncle](https://github.com/kuncle)\\n* [@liutang123](https://github.com/liutang123)\\n* [@luozenglin](https://github.com/luozenglin)\\n* [@luzhijing](https://github.com/luzhijing)\\n* [@MarsXDM](https://github.com/MarsXDM)\\n* [@mh-boy](https://github.com/mh-boy)\\n* [@mk8310](https://github.com/mk8310)\\n* [@morningman](https://github.com/morningman)\\n* [@Myasuka](https://github.com/Myasuka)\\n* [@nimuyuhan](https://github.com/nimuyuhan)\\n* [@pan3793](https://github.com/pan3793)\\n* [@PatrickNicholas](https://github.com/PatrickNicholas)\\n* [@pengxiangyu](https://github.com/pengxiangyu)\\n* [@pierre94](https://github.com/pierre94)\\n* [@qidaye](https://github.com/qidaye)\\n* [@qzsee](https://github.com/qzsee)\\n* [@shiyi23](https://github.com/shiyi23)\\n* [@smallhibiscus](https://github.com/smallhibiscus)\\n* [@songenjie](https://github.com/songenjie)\\n* [@spaces-X](https://github.com/spaces-X)\\n* [@stalary](https://github.com/stalary)\\n* [@stdpain](https://github.com/stdpain)\\n* [@Stephen-Robin](https://github.com/Stephen-Robin)\\n* [@Sunt-ing](https://github.com/Sunt-ing)\\n* [@Taaang](https://github.com/Taaang)\\n* [@tarepanda1024](https://github.com/tarepanda1024)\\n* [@tianhui5](https://github.com/tianhui5)\\n* [@tinkerrrr](https://github.com/tinkerrrr)\\n* [@TobKed](https://github.com/TobKed)\\n* [@ucasfl](https://github.com/ucasfl)\\n* [@Userwhite](https://github.com/Userwhite)\\n* [@vinson0526](https://github.com/vinson0526)\\n* [@wangbo](https://github.com/wangbo)\\n* [@wangliansong](https://github.com/wangliansong)\\n* [@wangshuo128](https://github.com/wangshuo128)\\n* [@weajun](https://github.com/weajun)\\n* [@weihongkai2008](https://github.com/weihongkai2008)\\n* [@weizuo93](https://github.com/weizuo93)\\n* [@WindyGao](https://github.com/WindyGao)\\n* [@wunan1210](https://github.com/wunan1210)\\n* [@wuyunfeng](https://github.com/wuyunfeng)\\n* [@xhmz](https://github.com/xhmz)\\n* [@xiaokangguo](https://github.com/xiaokangguo)\\n* [@xiaoxiaopan118](https://github.com/xiaoxiaopan118)\\n* [@xinghuayu007](https://github.com/xinghuayu007)\\n* [@xinyiZzz](https://github.com/xinyiZzz)\\n* [@xuliuzhe](https://github.com/xuliuzhe)\\n* [@xxiao2018](https://github.com/xxiao2018)\\n* [@xy720](https://github.com/xy720)\\n* [@yangzhg](https://github.com/yangzhg)\\n* [@yx91490](https://github.com/yx91490)\\n* [@zbtzbtzbt](https://github.com/zbtzbtzbt)\\n* [@zenoyang](https://github.com/zenoyang)\\n* [@zh0122](https://github.com/zh0122)\\n* [@zhangboya1](https://github.com/zhangboya1)\\n* [@zhangstar333](https://github.com/zhangstar333)\\n* [@zuochunwei](https://github.com/zuochunwei)"}]}')}}]);